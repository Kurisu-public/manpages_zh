bash(1) -- GNU Bourne-Again命令解释程序
==========================================

##概述SYNOPSIS

bash[options][文件]

##描述DESCRIPTION

Bash是一个与sh兼容的命令解释程序，可以执行从标准输入或者文件中读取的命令。Bash也整合了Korn和CShell(ksh和csh)中的优秀特性。

Bash的目标是成为遵循IEEE POSIX Shell and Tools specification(IEEE Working Group 1003.2，可移植操作系统规约：shell和工具)的实现。

##选项OPTIONS

除了在`set(1)`内建命令的文档中讲述的单字符选项(option)之外，bash在启动时还解释下列选项。

* `−c string`:
如果有−c选项，那么命令将从string中读取。如果string后面有参数，它们将用于给位置参数，以$0起始赋值。
* `−i`:
如果有−i选项，shell将交互地执行。
* `−l`:
选项使得bash以类似登录shell的方式启动，读取用户配置选项。
* `−r`:
如果有−r选项，shell成为受限的(restricted)(参见下面的受限的shell(RESTRICTEDSHELL)章节)。
* `−s`:
如果有−s选项，或者如果选项处理完以后，没有参数剩余，那么命令将从标准输入读取。这个选项允许在启动一个交互shell时可以设置位置参数。
* `−D`:
向标准输出打印一个以$为前导的，以双引号引用的字符串列表。这是在当前语言环境不是C或POSIX时，脚本中需要翻译的字符串。这个选项隐含了−n选项；不会执行命令。
* [−+]O[shopt_option]:
shopt_option是一个shopt内建命令可接受的选项(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节)。如果有shopt_option，−O将设置那个选项的取值；+O取消它。如果没有给出shopt_option，shopt将在标准输出上打印设为允许的选项的名称和值。如果启动选项是+O，输出将以一种可以重用为输入的格式显示。
* −−:
−−标志选项的结束，禁止其余的选项处理。任何−−之后的参数将作为文件名和参数对待。参数−与此等价。

Bash也解释一些多字节的选项。在命令行中，这些选项必须置于单字符参数之前。
* −−dump−po−strings:
等价于−D，但是输出是GNU gettextpo(可移植对象)文件格式
* −−dump−strings:
等价于−D
* −−help:
在标准输出显示用法信息并成功退出
﹡`−−init−file file` 或 `−−rcfile file`
如果shell是交互的，执行file中的命令，而不是标准的个人初始化文件~/.bashrc(参见下面的启动(INVOCATION)章节)
﹡−−login
等价于−l
* −−noediting:
如果shell是交互的，不使用GNU `readline`库来读命令行
﹡−−noprofile
不读取系统范围的启动文件`/etc/profile`或者任何个人初始化文件`~/.bash_profile`,`~/.bash_login`,或`~/.profile`。默认情况下，bash在作为登录shell启动时读取这些文件。
﹡−−norc
如果shell是交互的，不读取/执行个人初始化文件~/.bashrc这个选项在shell以sh命令启动时是默认启用的
﹡−−posix
如果默认操作与POSIX1003.2标准不同的话，改变bash的行为来符合标准(posix mode)
* −−restricted
shell成为受限的(参见下面的受限的shell(RESTRICTED SHELL)章节)
* −−rpm-requires
产生一个为使脚本运行，需要的文件的列表。这个选项包含了−n选项。它是为了避免进行编译期错误检测时的限制－－Backticks,[]tests,还有evals不会被解释，一些依赖关系可能丢失
* −−verbose
等价于−v
−−version
在标准输出显示此bash的版本信息并成功退出。

##参数(ARGUMENTS)

如果选项处理之后仍有参数剩余，并且没有指定−c或−s选项，第一个参数将假定为一个包含shell命令的文件的名字。如果bash是以这种方式启动的，$0将设置为这个文件的名字，位置参数将设置为剩余的其他参数。Bash从这个文件中读取并执行命令，然后退出。Bash的退出状态是脚本中执行的最后一个命令的退出状态。如果没有执行命令，退出状态是0。尝试的步骤是先试图打开在当前目录中的这个文件，接下来，如果没有找到，shell将搜索脚本的PATH环境变量中的路径。

##启动(INVOCATION)

login shell登录shell，参数零的第一个字符是−，或者启动时指定了−−login选项的shell。

interactive交互的shell，是一个启动时没有指定非选项的参数，并且没有指定−c选项，标准输出和标准输入都连接到了终端(在isatty(3)中判定)的shell，或者启动时指定了−i选项的shell。如果bash是交互的，PS1环境变量将被设置，并且$−包含i，允许一个shell脚本或者一个启动文件来检测这一状态。

下列段落描述了bash如何执行它的启动文件。如果这些启动文件中的任一个存在但是不可读取，bash将报告一个错误。文件名中的波浪号(~,tilde)将像EXPANSION章节中TildeExpansion段描述的那样展开。

当bash是作为交互的登录shell启动的，或者是一个非交互的shell但是指定了−−login选项，它首先读取并执行/etc/profile中的命令，只要那个文件存在。读取那个文件之后，它以如下的顺序查找~/.bash_profile,~/.bash_login,和~/.profile,从存在并且可读的第一个文件中读取并执行其中的命令。−−noprofile选项可以用来在shell启动时阻止它这样做。

当一个登录shell退出时，bash读取并执行文件~/.bash_logout中的命令，只要它存在。

当一个交互的shell但不是登录shell启动时，bash从文件~/.bashrc中读取并执行命令，只要它存在。可以用−−norc选项来阻止它这样做。−−rcfilefile选项将强制bash读取并执行文件file中的命令，而不是~/.bashrc中的。

当bash以非交互的方式启动时，例如在运行一个shell脚本时，它在环境中查找变量`BASH_ENV`，如果它存在则将它的值展开，使用展开的值作为一个文件的名称，读取并执行。Bash运作的过程就如同执行了下列命令:

	if[−n"$BASH_ENV"];then."$BASH_ENV";fi

但是没有使用PATH变量的值来搜索那个文件名。

如果bash以名称sh启动，它试图模仿(mimic)sh历史版本的启动过程，尽可能地相似，同时也遵循POSIX标准。当作为交互式登录shell启动时,或者是非交互但使用了−−login选项启动的时候,它首先尝试读取并执行文件/etc/profile和~/.profile,中的命令.选项−−noprofile用于避免这种行为.当使用命令sh来启动一个交互式的shell时,bash查找环境变量ENV,如果有定义的话就扩展它的值,然后使用扩展后的值作为要读取和执行的文件的名称.由于使用sh启动的shell不会读取和执行任何其他的启动文件,选项−−rcfile没有意义.使用名称sh启动的非交互的shell不会读取任何其他启动文件.当以sh启动时,bash在读取启动文件之后进入posix模式.

当bash以posix模式启动时,(和使用−−posix命令行参数效果相同),它遵循POSIX标准。这种模式下,交互式shell扩展ENV环境变量的值,读取并执行以扩展后值为文件名的配置文件。不会读取其他文件。

Bash试着检测它是不是由远程shell守护程序,通常为rshd启动的.如果bash发现它是由rshd启动的,它将读取并执行~/.bashrc文件中的命令,只要这个文件存在并且可读.如果以sh命令启动,它不会这样做.选项−−norc可以用来阻止这种行为,选项−−rcfile用来强制读取另一个文件,但是通常rshd不会允许它们,或者用它们来启动shell

如果shell是以与真实用户(组)id不同的有效用户(组)id来启动的,并且没有−选项,那么它不会读取启动文件,也不会从环境中继承shell函数.环境变量中如果出现SHELLOPTS，它将被忽略.有效用户id将设置为真实用户id.如果启动时给出了−选项,那么启动时的行为是类似的,但是不会重置有效用户id.

##定义(DEFINITIONS)

下列定义在文档余下部分中通用.
* blank空白:
一个空格或是tab.
* word词:
一个字符序列,shell将它们视为一个结构单元.也称为一个token片段。
* name名称:
一个只由字母,数字和下划线构成的词,并且以字符或下划线起始.也称为一个wordidentifier标识符.
* metacharacter元字符
一个字符,如果不是引用的话,将成为词的分隔符.它是如下字符之一:
|&;()<>spacetab

control operator控制操作符
一个token(标识),拥有控制功能.它是如下符号之一:
||&&&;;;()|<newline>

##保留字(RESERVED WORDS)

Reserved words(保留字)是对shell有特殊意义的词.下列词被识别为保留的,如果不是引用,并且不是一个简单命令的起始词(参见下面的shell语法("SHELLGRAMMAR")),也不是case或者for命令的第三个词:
!casedodoneelifelseesacfiforfunctionifinselectthenuntilwhile{}time[[]]

##shell语法("SHELLGRAMMAR")

* Simple Commands简单命令:

simplecommand(简单命令)是(可选的)一系列变量赋值,紧接着是blank(空格)分隔的词和重定向,然后以一个controloperator结束.第一个词指明了要执行的命令,它被作为第0个参数.其余词被作为这个命令的参数.simplecommand简单命令的返回值是它的退出状态,或是128+n,如果命令被signal(信号)n结束的话.

* Pipelines管道:

pipeline(管道)是一个或多个命令的序列，用字符|分隔。管道的格式是这样:
	[time [−p]][!]command[|command2...]
命令command的标准输出通过管道连接到命令command2的标准输入。连接是在命令指定的任何重定向之前进行的。

如果保留字!作为管道前缀，管道的退出状态将是最后一个命令的退出状态的逻辑非值。否则，管道的退出状态就是最后一个命令的。shell在返回退出状态值之前，等待管道中的所有命令返回。
如果保留字time作为管道前缀，管道中止后将给出执行管道耗费的用户和系统时间。选项−p将使输出符合POSIX指定的格式。环境变量TIMEFORMAT可以设置为一个格式字符串，指定时间信息应当如何显示；参见下面的ShellVariables环境变量中TIMEFORMAT的讲述。
管道中的每个命令都作为单独的进程来执行(即在一个子shell中启动)。

* Lists序列

list(序列)是一个或多个管道，用操作符;,&,&&,或⎪⎪分隔的序列,并且可以选择用;,&,或<newline>新行符结束.
这些序列操作符中，&&和⎪⎪优先级相同，其次是;和&,它们的优先级是相同的。
序列中可以有一个或多个新行符来分隔命令，而不是使用分号分隔。
如果一个命令是由控制操作符&结束的,shell将在后台的子shell中执行这个命令。shell不会等待命令执行结束，返回状态总是0。以分号;分隔的命令会被顺序执行；shell会等待每个命令依次结束。返回状态是最后执行的命令的返回状态。
控制操作符&&和⎪⎪分别代表AND和OR序列。一个AND序列的形式是
command1&&command2
command2只有在command1返回0时才被执行。
一个OR序列的形式是
command1⎪⎪command2
command2只有在command1返回非0状态时才被执行。AND和OR序列的返回状态是序列中最后执行的命令的返回状态。

* CompoundCommands复合命令
compoundcommand(复合命令)是如下情况之一：
(list)
list序列将在一个子shell中执行。变量赋值和影响shell环境变量的内建命令在命令结束后不会再起作用。返回值是序列的返回值。
{list;}
list序列将在当前shell环境中执行。序列必须以一个新行符或分号结束。这种做法也称为groupcommand(命令组)。返回值是序列的返回值。注意与元字符(和不同，{和}是reservedwords(保留字)，必须出现在能够识别保留字的场合。由于它们不会产生断词(causeawordbreak)，它们和序列之间必须用空格分开。
((expression))
表达式expression将被求值。求值规则在下面的算术求值(ARITHMETICEVALUATION)章节中描述。如果表达式的值非零，返回值就是0；否则返回值是1。这种做法和let"expression"等价。
[[expression]]
返回0或1，取决于条件表达式expression求值的情况。表达式是由下面CONDITIONALEXPRESSIONS条件表达式章节中描述的原语(primaries)组成。[[和]]中的词不会进行词的拆分和路径的扩展处理；而tilde扩展，参数和变量扩展，算术扩展，命令替换，函数替换和引用的去除则都将进行。
当使用==和!=操作符时，操作符右边的字符串被认为是一个模式，根据下面PatternMatching(模式匹配)章节中的规则进行匹配。如果匹配则返回值是0，否则返回1。模式的任何部分可以被引用，强制使它作为一个字符串而被匹配。
表达式可以用下列操作符结合起来。根据优先级的降序列出如下：
(expression)
返回表达式expression的值。括号可以用来提升操作符的优先级。
!expression
返回真，如果表达式expression返回假。
expression1&&expression2
返回真，如果表达式expression1和expression2都返回真。
expression1||expression2
返回真，如果表达式expression1或者expression2二者之一返回真。
&&(与)和||操作符不会对表达式expression2求值，如果expression1可以决定整个条件表达式的返回值的话。
forname[inword];dolist;done
in之后的一系列词会被扩展，产生一个项目列表。变量name被依次赋以这个列表中的每个元素，序列list每次都被执行。如果inword被忽略，那么for命令遍历已设置的位置参数(positionalparameter，参见下面的PARAMETERS参数)，为每一个执行一次序列list。返回值是最后一个命令的返回值。如果in之后的词扩展的结果是空列表，就不会执行任何命令，返回值是0。
for((expr1;expr2;expr3));dolist;done
首先，算术表达式expr1被根据下面算术求值(ARITHMETICEVALUATION)中的规则进行求值。然后算术表达式expr2被循环求值，直到它等于0。每次expr2结果非零时，序列list都被执行，算术表达式expr3被求值。如果任何表达式被忽略，将被视为执行结果是1。返回值是序列list中被执行的最后一个命令的返回值；或者是false，如果任何表达式非法的话。
selectname[inword];dolist;done
in之后的一系列词会被扩展，产生一个项目列表。这个扩展后的词集合被输出到标准错误上，每个前面加上一个数字。如果inword被忽略，将输出位置参数(参见下面的PARAMETERS参数章节)。PS3提示符将被显示出来，等待从标准输入得到一行输入。如果输入是一个数字且显示中有对应的词，那么变量name的值将设置为这个词。如果输入一个空行，那么词和提示符将再次显示出来。如果读入了一个EOF，命令就结束。任何其他值将设置变量name为空。读入的行保存为变量REPLY.序列list在每次选择之后都会执行，直到执行了一个break命令。select的退出状态是序列list中执行的最后一个命令的退出状态，如果没有执行命令就是0。
casewordin[[(]pattern[|pattern]...)list;;]...esac
case命令首先扩展word,然后依次试着用每个pattern来匹配它，使用与路径扩展相同的匹配规则(参见下面的PathnameExpansion路径扩展章节)。如果找到一个匹配，相应的序列将被执行。找到一个匹配之后，不会再尝试其后的匹配。如果没有模式可以匹配，返回值是0。否则，返回序列中最后执行的命令的返回值。
iflist;thenlist;[eliflist;thenlist;]...[elselist;]fi
序列iflist被执行。如果退出状态是0，thenlist将被执行。否则，每个elif将被一次执行，如果退出状态是0，相应的thenlist将被执行，命令结束。否则，elselist将被执行，如果存在的话。退出状态是最后执行的命令的退出状态，或者是0，如果所有条件都不满足。
whilelist;dolist;done
untillist;dolist;done
while命令不断地执行序列dolist，直到序列中最后一个命令返回0。until命令和while命令等价，除了对条件的测试恰好相反；序列dolist执行直到序列中最后一个命令返回非零状态值。while和until命令的退出状态是序列dolist中最后一个命令的退出状态，或者是0，如果没有执行任何命令。
[function]name(){list;}
这样可以定义一个名为name的函数。函数体body是包含在{和}之间的命令序列list。在指定将name作为一个命令运行的场合，这个序列将被执行。函数的退出状态是函数体最后执行的命令的退出状态(参见下面的FUNCTIONS函数章节)。
注释(COMMENTS)

在非交互的shell中或者使用内建命令shopt启用了interactive_comments选项的交互的shell中，以#起始的词使得这个词和所有同一行上所有剩余的字符都被忽略。没有启用interactive_comments选项的交互式shell不允许出现注释。这个选项在交互式shell中是默认启用的(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节)。
引用(QUOTING)

引用Quoting用来去掉特定字符或词的特殊意义。引用可以用来禁止对特殊字符的处理，阻止保留字被识别，还用来阻止参数的扩展。
上面在DEFINITIONS定义中列出的每个元字符metacharacters对于shell都有特殊意义。如果要表达它的本义，必须引用它。
在使用命令行历史扩展功能时，historyexpansion字符，通常是!，必须被引用，才不会进行历史扩展。
有三种引用机制：转义字符(escapecharacter),单引号和双引号。
一个未被引用的反斜杠(\)是转义字符escapecharacter。它保留其后下一个字符的字面意义，除非那是一个新行符。如果\和新行符成对出现，并且反斜杠自身没有被引用，那么\<newline>被视为续行标志(意思是，它被从输入流中删除并忽略了)。
将字符放在单引号之中，将保留引用中所有字符的字面意义。单引号不能包含在单引号引用之中，即使前面加上了反斜杠。
将字符放在双引号中，同样保留所有字符的字面意义，例外的情况是$,‘,和\。字符$和‘在双引号中仍然具有特殊意义。反斜杠只有后面是下列字符时才有特殊意义：$,‘,",\,或<newline>.双引号可以包含在双引号引用中，但要在前面加上一个反斜杠。
特殊的参数*和@在双引号中有特殊意义(参见下面的PARAMETERS参数章节)。
形式为$’string’的词会被特殊处理。它被扩展为string，其中的反斜杠转义字符被替换为ANSIC标准中规定的字符。反斜杠转义序列，如果存在的话，将做如下转换：
\a
alert(bell)响铃
\b
backspace回退
\e
anescapecharacter字符Esc
\f
formfeed进纸
\n
newline新行符
\r
carriagereturn回车
\t
horizontaltab水平跳格
\v
verticaltab竖直跳格
\\
backslash反斜杠
\’
singlequote单引号
\nnn
一个八比特字符，它的值是八进制值nnn(一到三个数字)。
\xHH
一个八比特字符，它的值是十六进制值HH(一到两个十六进制数字)。
\cx
一个ctrl-x字符
扩展结果是单引号引用的，就好像$符号不存在一样。
双引号引用字符串前面加上一个$符号将使得这个字符串被根据当前语言环境(locale)来翻译。如果当前语言环境是C或者POSIX，这个符号将被忽略。如果这个字符串被翻译并替换了，那么替换结果是双引号引用的。
参数(PARAMETERS)

一个参数parameter是一个储存值的实体。它可以是一个名称name,一个数字或者是下面SpecialParameters特殊参数章节中列出的特殊字符之一。从shell的角度来看，一个变量variable是一个由名称name代表的参数。一个变量有一个值value以及零个或多个属性attibutes。属性可以使用内建命令declare来设置(参见下面shell内建命令(SHELLBUILTINCOMMANDS)章节中对declare的描述)。
如果给一个参数赋值，那么它就被定义了。空字符串是有效的值。一旦一个变量被定义了，它只能用内建命令unset来取消(参见下面shell内建命令(SHELLBUILTINCOMMANDS)章节).
一个变量variable可以用这样的语句形式来赋值：
name=[value]
如果没有给出值value，变量就被赋为空字符串。所有值values都经过了波浪线扩展，参数和变量扩展，命令替换，算术扩展和引用的删除(参见下面的EXPANSION扩展章节)。如果变量设置了integer整数属性，那么值value将进行算术扩展，即使没有应用$((...))扩展(参见下面的ArithmeticExpansion算术扩展章节)。不会进行词的拆分，除非是下面SpecialParameters特殊参数中提到的"$@"。不会进行路径的扩展。赋值语句也出现在下列内建命令中，作为它们的参数：declare,typeset,export,readonly,和local。
PositionalParameters位置参数
位置参数positionalparameter是以一或多个数字代表的参数，除了0。位置参数是在shell启动时，根据它的参数来赋值的，也可以用内建命令set来重新赋值。位置参数不能用赋值语句来赋值。在一个shell函数被执行的时候，位置参数会被暂时地替换掉(参见下面的FUNCTIONS函数章节)。
当位置参数由两个以上的数字构成时，它必须放在括号内(参见下面的EXPANSION扩展章节)。
SpecialParameters特殊参数
shell对一些参数做特殊处理。这些参数只能被引用而不能被赋值。
*
扩展为位置参数，从1开始。如果扩展发生在双引号中，它扩展为一个词，值是各个参数，以特殊变量IFS的第一个字符分隔。也就是说，"$*"等价于"$1c$2c..."，这里c是变量IFS的第一个字符。如果没有设置IFS，那么参数将用空格分隔。IFS
@
扩展为位置参数，从1开始。如果扩展发生在双引号中，每个参数都将扩展为一个词。也就是说，"$@"等价于"$1""$2"...如果位置参数不存在，"$@"和$@扩展为空(即，它们被删除了)。
#
扩展为位置参数的个数，以十进制表示。
?
扩展为最近执行的前台管道的状态。
−
扩展为当前选项标志。标志是在启动时或以内建命令set指定的，或者是shell自身设置的(例如选项−i)。
$
扩展为shell的进程ID。在一个()子shell中，它扩展为当前shell的进程ID而不是子shell的。
!
扩展为最近一次执行的后台(异步)命令的进程号。
0
扩展为shell或者shell脚本的名称。这个变量是在shell初始化时设置的。如果bash是执行脚本文件时启动的，$0将设置为那个文件的名称。如果bash启动时的参数包含−c，那么$0被设置为启动命令行被执行后的第一个参数，如果有的话。否则，它被设置为用来启动bash的文件名，就是参数0。
_
shell启动时，设置为shell或参数中被执行的shell脚本的绝对路径名。然后，在扩展时扩展为上一个命令的最后一个参数。它也被设置为被执行的每个命令的文件全名并且被设置到这个命令执行的环境当中。当检查邮件时，这个参数保存着正在检查的邮件文件的名称。
ShellVariables变量
shell定义了下列变量：
BASH
扩展为用来启动当前bash实例的文件全名。
BASH_VERSINFO
一个只读数组变量，成员保存着当前bash实例的版本信息。赋予数组元素的值是如下这些：
BASH_VERSINFO[0]
主版本号(release).
BASH_VERSINFO[1]
次版本号(version).
BASH_VERSINFO[2]
补丁版本
BASH_VERSINFO[3]
编译信息
BASH_VERSINFO[4]
发布时的状态(例如,beta1).
BASH_VERSINFO[5]
MACHTYPE平台类型
BASH_VERSION
扩展为一个字符串，描述了这个bash.实例的版本。
COMP_CWORD
${COMP_WORDS}的索引，指向当前光标位置所在的词。这个变量只有在被可编程补全功能(参见下面的ProgrammableCompletion章节)调用的shell函数中才可用。
COMP_LINE
当前命令行。这个变量只有在被命令补全功能调用的shell函数和外部命令中才可用。
COMP_POINT
相对于当前命令起始处的当前光标位置。如果当前光标位置是当前命令的末端，它的值就和${#COMP_LINE}相等。这个变量只有在被命令补全功能调用的shell函数和外部命令中才可用。
COMP_WORDS
一个数组变量(参见下面的Arrays(数组)一节)，由当前命令行的各个单词构成。这个变量只有在被命令补全功能调用的shell函数中才可用。
DIRSTACK
一个数组变量，包含当前目录栈的内容。栈中的目录排列的顺序就是用内建命令dirs显示时的顺序。对这个数组变量的成员赋值可以用来修改栈中已有的目录，但是要添加和删除目录就必须使用内建命令pushd和popd。对它赋值不会改变当前目录。如果取消了DIRSTACK的定义，它就失去了它的特殊意义，即使后来重新定义它。
EUID
扩展为当前用户的有效用户ID。它在shell启动时设置。它是只读的。
FUNCNAME
当前执行的shell函数名。这个变量只有在执行一个shell函数时存在。向FUNCNAME赋值没有效果并且返回一个错误。如果取消了FUNCNAME的定义，它就失去了特殊的意义，即使后来重新定义它。
GROUPS
一个数组变量，包含当前用户所属的组的列表。向GROUPS赋值没有效果并且返回一个错误。如果取消了GROUPS的定义，它就失去了特殊的意义，即使后来重新定义它。
HISTCMD
当前命令的历史编号，或者历史列表中的索引。如果取消了HISTCMD的定义，它就失去了特殊的意义，即使后来重新定义它。
HOSTNAME
自动设置为当前的主机名。
HOSTTYPE
自动设置为一个字符串，唯一地标识着正在运行bash的机器类型。默认值是系统相关的。
LINENO
每次引用这个参数时，shell将它替换为一个指示在脚本或函数中当前行号的十进制数字(从1开始)。如果不是在脚本或函数中，替换得到的值不一定有意义。如果取消了LINENO的定义，它就失去了特殊的意义，即使后来重新定义它。
MACHTYPE
自动设置为一个字符串，完整的描述了正在运行bash的系统类型，格式是标准的GNUcpu-company-system格式。默认值是系统相关的。
OLDPWD
上一次命令cd设置的工作目录。
OPTARG
内建命令getopts处理的最后一个选项参数值(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节)。
OPTIND
内建命令getopts将处理的下一个参数的索引(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节)。
OSTYPE
自动设置的一个字符串，描述了正在运行bash的操作系统。默认值是系统相关的。
PIPESTATUS
一个数组变量(参见下面的Arrays数组章节)，包含最近执行的前台管道中的进程(可能只包含一个命令)的退出状态。
PPID
shell的父进程的进程号。这个变量是只读的。
PWD
由cd命令设置的当前工作目录。
RANDOM
每次引用这个参数时，都会产生一个0到32767之间的随机整数。可以通过向RANDOM赋值来初始化随机数序列。如果取消了RANDOM的定义，它就失去了特殊的意义，即使后来重新定义它。
REPLY
变量的值将作为内建命令read的输入，如果命令没有参数的话。
SECONDS
每次引用这个参数时，返回shell自运行以来的秒数。如果向SECONDS赋值，此后对它的引用将返回自赋值时起的秒数加上所赋予的值。如果取消SECONDS的定义，它就失去了特殊的意义，即使后来重新定义它。
SHELLOPTS
一个冒号分隔的被允许的shell选项列表。列表中每个词都是内置命令set的−o选项的有效参数。SHELLOPTS中出现的选项也是set−o显示为on的选项。如果bash启动时从环境中找到这个变量，那么在读取任何配置文件之前，列表中的每个选项都将被设置。这个变量是只读的。
SHLVL
每次启动一个bash的实例时都会增加。
UID
扩展为当前用户的ID，在启动时初始化。这个变量是只读的。
下列变量被shell使用。有时bash会为变量赋默认值；这些情况在下面会标出。
BASH_ENV
如果bash在执行一个shell脚本时设定了这个变量，它的值将被解释为一个文件名，包含着初始化shell用到的命令，就像~/.bashrc中一样。BASH_ENV的值在被解释为一个文件名之前要经过参数扩展，命令替换和算术扩展。不会使用PATH来查找结果文件名。
CDPATH
命令cd的搜索路径。这是一个冒号分隔的目录列表，shell从中查找cd命令的目标目录。可以是这样：".:~:/usr".
COLUMNS
用在内建命令select当中，用来判断输出选择列表时的终端宽度。自动根据SIGWINCH信号来设置。
COMPREPLY
一个数组变量，bash从中读取可能的命令补全。它是由命令补全功能调用的shell函数产生的。
FCEDIT
内建命令fc默认的编辑器。
FIGNORE
一个冒号分隔的后缀名列表，在进行文件名补全时被忽略(参见下面的READLINE章节)。一个后缀满足其中之一的文件名被排除在匹配的文件名之外。可以是这样：".o:~".
GLOBIGNORE
一个冒号分隔的模式列表，定义了路径名扩展时要忽略的文件名集合。如果一个文件名与路径扩展模式匹配，同时匹配GLOBIGNORE中的一个模式时，它被从匹配列表中删除。
HISTCONTROL
如果设置为ignorespace,以space开头的行将不会插入到历史列表中。如果设置为ignoredups,匹配上一次历史记录的行将不会插入。设置为ignoreboth会结合这两种选项。如果没有定义，或者设置为其他值，所有解释器读取的行都将存入历史列表，但还要经过HISTIGNORE处理。这个变量的作用可以被HISTIGNORE替代。多行的组合命令的第二和其余行都不会被检测，不管HISTCONTROL是什么，都会加入到历史中。
HISTFILE
保存命令历史的文件名(参见下面的HISTORY历史章节)。默认值是~/.bash_history。如果取消定义，在交互式shell退出时命令历史将不会保存。
HISTFILESIZE
历史文件中包含的最大行数。当为这个变量赋值时，如果需要的话，历史文件将被截断来容纳不超过这个值的行。默认值是500。历史文件在交互式shell退出时也会被截断到这个值。
HISTIGNORE
一个冒号分隔的模式列表，用来判断那个命令行应当保存在历史列表中。每个模式都定位于行首，必须匹配整行(没有假定添加‘*’)。在HISTCONTROL指定的测试结束后，这里的每个模式都要被测试。除了平常的shell模式匹配字符，‘&’匹配上一个历史行。‘&’可以使用反斜杠来转义；反斜杠在尝试匹配之前将被删除。多行的组合命令的第二行以及后续行都不会被测试，不管HISTIGNORE是什么，都将加入到历史中。
HISTSIZE
命令历史中保存的历史数量(参见下面的HISTORY历史章节)。默认值是500。
HOME
当前用户的个人目录；内建命令cd的默认参数。在执行波浪线扩展时也用到这个变量。
HOSTFILE
包含一个格式和/etc/hosts相同的文件名，当shell需要补全主机名时要读取它。shell运行过程中可以改变可能的主机名补全列表；改变之后下一次需要主机名补全时bash会将新文件的内容添加到旧列表中。如果定义了HOSTFILE但是没有赋值，bash将尝试读取/etc/hosts文件来获得可能的主机名补全列表。当取消HOSTFILE的定义时，主机名列表将清空。
IFS
内部字段分隔符InternalFieldSeparator用来在扩展之后进行分词，使用内部命令read将行划分成词。默认值是‘‘<space><tab><newline>’’。
IGNOREEOF
控制交互式shell接受到唯一一个EOF字符时的行为。如果有定义，值是需要在一行的开始连续输入EOF字符，直到可以使bash退出的字符个数。如果这个变量存在，但是值不是一个数字或者没有赋值，默认值是10。如果变量没有定义，EOF标志着输入的结束。
INPUTRC
readline的启动配置文件，而不是默认的~/.inputrc(参见下面的READLINE章节)。
LANG
用来决定没有特地用LC_变量指定的语言环境项。
LC_ALL
这个变量超越了LANG和所有其他指定语言环境项的LC_变量。
LC_COLLATE
这个变量决定了为路径扩展的结果排序时的字母顺序，决定了范围表达式的行为，等价类，和路径扩展中的归并顺序以及模式匹配。
LC_CTYPE
这个变量决定了字符的解释和路径扩展以及模式匹配中字符类的行为。
LC_MESSAGES
这个变量决定了翻译以$前导的双引号字符串时的语言环境。
LC_NUMERIC
这个变量决定了格式化数字时的语言环境分类。
LINES
内建命令select用它来判断输出选择列表时的列宽度。在收到SIGWINCH信号时自动设置。
MAIL
如果这个参数设置为一个文件名，并且没有设置环境变量MAILPATH的话，bash将在这个文件中通知用户有邮件到达。
MAILCHECK
指定bash检查邮件的频率是多少，以秒为单位。默认值是60秒。需要检查邮件的时候，shell在显示提示符之前将进行检查。如果取消它的定义，或者设置为并非大于等于零的数值，shell将禁止邮件检查。
MAILPATH
一个冒号分隔的文件名列表，从中检查邮件。当邮件到达某个特殊文件中时，输出的特定消息可以通过将文件名与消息以‘?’分隔来指定。在消息的文本中，$_扩展为当前邮件文件的文件名。例如：
MAILPATH=’/var/mail/bfox?"Youhavemail":~/shell−mail?"$_hasmail!"’
Bash为这个变量提供默认值，但是它使用的用户邮件文件的位置是系统相关的(例如，/var/mail/$USER)。
OPTERR
如果设置为1，bash显示内建命令getopts产生的错误消息(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节)。每次shell启动时或者一个shell脚本被执行时OPTERR被初始化为1。
PATH
搜索命令的路径。它是一个冒号分割的目录列表，shell从中搜索命令(参见下面的命令执行(COMMANDEXECUTION)段落)。默认的路径是系统相关的，是由安装bash的系统管理员设置的。通常它的值是‘‘/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.’’。
POSIXLY_CORRECT
如果bash启动环境中有这个变量，它将在读取启动配置文件之前进入posixmode，就好像提供了−−posix启动参数一样。如果shell运行过程中设置了它，bash就启用posixmode，就好像执行了set-oposix命令一样。
PROMPT_COMMAND
如果有定义，它的值将作为一个命令，每次显示主提示符之前都会执行。
PS1
这个参数的值被扩展(参见下面的PROMPTING提示符段落)，用作主提示符字符串。默认值是‘‘\s−\v\$’’。
PS2
这个参数的值同PS1一起被扩展，用作次提示符字符串。默认值是‘‘>’’。
PS3
这个参数的值被用作内建命令select的提示符(参见上面的SHELLGRAMMAR语法章节)。
PS4
这个参数的值同PS1一起被扩展，在执行跟踪中在bash显示每个命令之前显示。需要的话，PS4的第一个字符会被复制多次，来指示indirection的层数。默认值是‘‘+’’。
TIMEFORMAT
在前缀time保留字的管道中，这个参数的值用作格式字符串，指定计时信息如何显示。字符%引入的转义序列，被扩展为时间值或其他信息。转义序列和它们的含义如下所示；括号中是可选的成分。
%%
一个字面上的%。
%[p][l]R
经历的时间，以秒计算。
%[p][l]U
CPU在用户模式下执行的秒数。
%[p][l]S
CPU在系统模式下执行的秒数。
%P
CPU使用率，算法是(%U+%S)/%R。
可选的p是指定精度(小数点后数字位数)的数值。如果是0就不输出小数点或小数值。最多指定到小数点后三位；如果p大于3就会被改为3。如果没有指定p，默认使用3。
可选的l指定了长格式，包含分钟，格式是MMmSS.FFs。p的值决定了是不是包含小数位。
如果没有设置这个值，bash假定它的值是$’\nreal\t%3lR\nuser\t%3lU\nsys%3lS’。如果它是空值，就不会显示计时信息。显示格式字符串的时候，会加上一个前导的新行符。
TMOUT
如果设置为大于0的值，TMOUT被当作内建命令read的默认超时等待时间。如果等待终端输入时，TMOUT秒之后仍然没有输入，select命令将终止。在交互的shell中，它的值被解释为显示了主提示符之后等待输入的秒数。如果经过这个秒数之后仍然没有输入，Bash将退出。
auto_resume
这个变量控制了shell如何与用户和作业控制交互。如果设置了这个变量，一个不包含重定向的单个词的简单命令，将作为恢复被中断的作业的指示。不允许出现模棱两可的情况；如果有多个作业都以这个词起始，将恢复最近运行的作业。在这种情形下，被中断的作业的name是用于启动它的命令行。如果值设置为exact，给出的字符串必须精确匹配被中断的作业名；如果设置为substring，给出的字符串需要匹配被中断的作业名的子串。值substring的功能与作业标识符%?功能类似(参见下面的JOBCONTROL作业控制章节)。如果设置为任何其他值，给出的字符串必须是被中断的作业的前缀；这样做与作业标识符%功能类似。
histchars
两到三个字符，控制着历史扩展和分段(tokenization，参见下面的HISTORYEXPANSION历史扩展章节)。第一个字符是historyexpansion(历史扩展)字符，这个字符表明了历史扩展的开始，通常是‘!’。第二个字符是quicksubstitution(快速替换)字符，它是重新运行上次输入的命令，但将命令中的字符串替换为另一个的简写，默认是‘^’。可选的第三个字符是指示如果作为一个词的开始，那么一行中剩余字符是注释。通常这个字符是‘#’。历史注释字符使得对一行中剩余字符在历史替换中被跳过。它不一定使shell解释器将这一行的剩余部分当作注释。
Arrays
Bash提供了一维数组变量。任何变量都可以作为一个数组；内建命令declare可以显式地定义数组。数组的大小没有上限，也没有限制在连续对成员引用和赋值时有什么要求。数组以整数为下标，从0开始。
如果变量赋值时使用语法name[subscript]=value，那么就会自动创建数组。subscript被当作一个算术表达式，结果必须是大于等于0的值。要显式地定义一个数组，使用declare−aname(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节)。也可以用declare−aname[subscript]这时subscript被忽略。数组变量的属性可以用内建命令declare和readonly来指定。每个属性对于所有数组元素都有效。
数组赋值可以使用复合赋值的方式，形式是name=(value1...valuen)，这里每个value的形式都是[subscript]=string。string必须出现。如果出现了可选的括号和下标，将为这个下标赋值，否则被赋值的元素的下标是语句中上一次赋值的下标加一。下标从0开始。这个语法也被内建命令declare所接受。单独的数组元素可以用上面介绍的语法name[subscript]=value来赋值。
数组的任何元素都可以用${name[subscript]}来引用。花括号是必须的，以避免和路径扩展冲突。如果subscript是@或是*，它扩展为name的所有成员。这两种下标只有在双引号中才不同。在双引号中，${name[*]}扩展为一个词，由所有数组成员的值组成，用特殊变量IFS的第一个字符分隔；${name[@]}将name的每个成员扩展为一个词。如果数组没有成员，${name[@]}扩展为空串。这种不同类似于特殊参数*和@的扩展(参见上面的SpecialParameters段落)。${#name[subscript]}扩展为${name[subscript]}的长度。如果subscript是*或者是@，扩展结果是数组中元素的个数。引用没有下标数组变量等价于引用元素0。
内建命令unset用于销毁数组。unsetname[subscript]将销毁下标是subscript的元素。unsetname,这里name是一个数组，或者unsetname[subscript],这里subscript是*或者是@，将销毁整个数组。
内建命令declare,local,和readonly都能接受−a选项，从而指定一个数组。内建命令read可以接受−a选项，从标准输入读入一列词来为数组赋值。内建命令set和declare使用一种可以重用为输入的格式来显示数组元素。
扩展(EXPANSION)

命令行的扩展是在拆分成词之后进行的。有七种类型的扩展：braceexpansion(花括号扩展),tildeexpansion(波浪线扩展),parameterandvariableexpansion(参数和变量扩展),commandsubstitution(命令替换),arithmeticexpansion(算术扩展),wordsplitting(词的拆分),和pathnameexpansion(路径扩展).
扩展的顺序是：braceexpansion,tildeexpansion,parameter,variable和arithmeticexpansion还有commandsubstitution(按照从左到右的顺序),wordsplitting,最后是pathnameexpansion.
还有一种附加的扩展：processsubtitution(进程替换)只有在支持它的系统中有效。
只有braceexpansion,wordsplitting,和pathnameexpansion在扩展前后的词数会发生改变；其他扩展总是将一个词扩展为一个词。唯一的例外是上面提到的"$@"和"${name[@]}"(参见PARAMETERS参数)。
BraceExpansion
Braceexpansion是一种可能产生任意字符串的机制。这种机制类似于pathnameexpansion,但是并不需要存在相应的文件。花括号扩展的模式是一个可选的preamble(前导字符),后面跟着一系列逗号分隔的字符串，包含在一对花括号中，再后面是一个可选的postscript(附言)。前导被添加到花括号中的每个字符串前面，附言被附加到每个结果字符串之后，从左到右进行扩展。
花括号扩展可以嵌套。扩展字符串的结果没有排序；而是保留了从左到右的顺序。例如，a{d,c,b}e扩展为‘adeaceabe’。
花括号扩展是在任何其他扩展之前进行的，任何对其他扩展有特殊意义的字符都保留在结果中。它是严格字面上的。Bash不会对扩展的上下文或花括号中的文本做任何语义上的解释。
正确的花括号扩展必须包含没有引用的左括号和右括号，以及至少一个没有引用的逗号。任何不正确的表达式都不会被改变。可以用反斜杠来引用{或,来阻止将它们识别为花括号表达式的一部分。为了避免与参数扩展冲突，字符串${不被认为有效的组合。
这种结构通常用来简写字符串的公共前缀远比上例中为长的情况，例如：
mkdir/usr/local/src/bash/{old,new,dist,bugs}
或者：
chownroot/usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
花括号扩展导致了与历史版本的sh的一点不兼容。在左括号或右括号作为词的一部分出现时，sh不会对它们进行特殊处理，会在输出中保留它们。Bash将括号从花括号扩展结果的词中删除。例如，向sh输入file{1,2}会导致不变的输出。同样的输入在bash进行扩展之后，会输出file1file2.如果需要同sh严格地保持兼容，需要在启动bash的时候使用+B选项，或者使用set命令加上+B选项来禁用花括号扩展(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节)。
TildeExpansion
如果一个词以没有引用的波浪线字符(‘~’)开始，所有在第一个没有引用的斜线(‘/’)之前的字符(或者是这个词的所有字符，如果没有没引用的斜线的话)都被认为是tilde-prefix(波浪线前缀)。如果tilde-prefix中没有被引用的字符，那么波浪线之后的字符串被认为是loginname(登录名)。如果登录名是空字符串，波浪线将被替换为shell参数HOME的值。如果没有定义HOME，将替换为执行此shell的用户的个人目录。否则，tilde-prefix被替换为与指定登录名相联系的个人目录。
如果tilde-prefix是‘~+’，将使用shell变量PWD的值来替换。如果tilde-prefix是‘~−’，并且设置了shell变量OLDPWD,将使用这个变量值来替换。如果在tilde-prefix中，波浪线之后的字符串由一个数字N组成，前缀可选的‘+’或者‘−’，那么tilde-prefix将被替换为目录栈中相应的元素，就是将tilde-prefix作为参数执行内建命令dirs显示的结果。如果tilde-prefix中波浪线之后的字符是一个数字，没有前缀，那么就假定有一个‘+’。
如果登录名不合法，或者波浪线扩展失败，这个词将不会变化。
在变量赋值中，对于:或=之后的字符串会立即检查未引用的tilde-prefix。这种情况下，仍然会进行波浪线扩展。因此，可以使用带波浪线的文件名来为PATH,MAILPATH,和CDPATH赋值，shell将赋予扩展之后的值。
ParameterExpansion
字符‘$’引入了参数扩展，命令替换和算术扩展。要扩展的参数名或符号可能包含在花括号中，花括号可选的，但是可以使得要扩展的变量不会与紧随其后的字符合并，成为新的名称。
使用花括号的时候，匹配的右括号是第一个‘}’，并且它没有被反斜杠引用或包含在一个引用的字符串中，也没有包含在一个嵌入的算术扩展，命令替换或是参数扩展中。
${parameter}
被替换为parameter的值。如果parameter是一个位置参数，并且数字多于一位时；或者当紧随parameter之后有不属于名称一部分的字符时，都必须加上花括号。
如果parameter的第一个字符是一个感叹号，将引进一层间接变量。bash使用以parameter的其余部分为名的变量的值作为变量的名称；接下来新的变量被扩展，它的值用在随后的替换当中，而不是使用parameter自身的值。这也称为indirectexpansion(间接扩展).例外情况是下面讲到的${!prefix*}。
下面的每种情况中，word都要经过波浪线扩展，参数扩展，命令替换和算术扩展。如果不进行子字符串扩展，bash测试一个没有定义或值为空的参数；忽略冒号的结果是只测试未定义的参数。
${parameter:−word}
UseDefaultValues(使用默认值)。如果parameter未定义或值为空，将替换为word的扩展。否则，将替换为parameter的值。
${parameter:=word}
AssignDefaultValues(赋默认值)。如果parameter未定义或值为空，word的扩展将赋予parameter.parameter的值将被替换。位置参数和特殊参数不能用这种方式赋值。
${parameter:?word}
DisplayErrorifNullorUnset(显示错误，如果未定义或值为空)。如果parameter未定义或值为空，word(或一条信息，如果word不存在)的扩展将写入到标准错误；shell如果不是交互的，则将退出。否则，parameter的值将被替换。
${parameter:+word}
UseAlternateValue(使用可选值)。如果parameter未定义或非空，不会进行替换；否则将替换为word扩展后的值。
${parameter:offset}
${parameter:offset:length}
SubstringExpansion(子字符串扩展)。扩展为parameter的最多length个字符，从offset指定的字符开始。如果忽略了length，扩展为parameter的子字符串，从offset指定的字符串开始。length和offset是算术表达式(参见下面的ARITHMETICEVALUATION算术求值段落)。length必须是一个大于等于0的数值。如果offset求值结果小于0，值将当作从parameter的值的末尾算起的偏移量。如果parameter是@，结果是length个位置参数，从offset开始。如果parameter是一个数组名，以@或*索引，结果是数组的length个成员，从${parameter[offset]}开始。子字符串的下标是从0开始的，除非使用位置参数时，下标从1开始。
${!prefix*}
扩展为名称以prefix开始的变量名，以特殊变量IFS的第一个字符分隔。
${#parameter}
替换为parameter的值的长度(字符数目)。如果parameter是*或者是@,替换的值是位置参数的个数。如果parameter是一个数组名，下标是*或者是@,替换的值是数组中元素的个数。
${parameter#word}
${parameter##word}
word被扩展为一个模式，就像路径扩展中一样。如果这个模式匹配parameter的值的起始，那么扩展的结果是将parameter扩展后的值中，最短的匹配(‘‘#’’的情况)或者最长的匹配(‘‘##’’的情况)删除的结果。如果parameter是@或者是*,则模式删除操作将依次施用于每个位置参数，最后扩展为结果的列表。如果parameter是一个数组变量，下标是@或者是*,模式删除将依次施用于数组中的每个成员，最后扩展为结果的列表。
${parameter%word}
${parameter%%word}
word被扩展为一个模式，就像路径扩展中一样。如果这个模式匹配parameter扩展后的值的尾部，那么扩展的结果是将parameter扩展后的值中，最短的匹配(‘‘%’’的情况)或者最长的匹配(‘‘%%’’的情况)删除的结果。如果parameter是@或者是*,则模式删除操作将依次施用于每个位置参数，最后扩展为结果的列表。如果parameter是一个数组变量，下标是@或者是*,模式删除将依次施用于数组中的每个成员，最后扩展为结果的列表。
${parameter/pattern/string}
${parameter//pattern/string}
patterm被扩展为一个模式，就像路径扩展中一样。parameter被扩展，其值中最长的匹配pattern的内容被替换为string。在第一种形式中，只有第一个匹配被替换。第二种形式使得pattern中所有匹配都被替换为string。如果pattern以#开始，它必须匹配parameter扩展后值的首部。如果pattern以%开始，它必须匹配parameter扩展后值的尾部。如果string是空值，pattern的匹配都将被删除，pattern之后的/将被忽略。如果parameter是@或者是*,则替换操作将依次施用于每个位置参数，最后扩展为结果的列表。如果parameter是一个数组变量，下标是@或者是*,模式删除将依次施用于数组中的每个成员，最后扩展为结果的列表。
CommandSubstitution
命令替换(Commandsubstitution)允许以命令的输出替换命令名。有两种形式：
$(command)
还有
‘command‘
Bash进行扩展的步骤是执行command，以它的标准输出替换它，并且将所有后续的新行符删除。内嵌的新行符不会删除，但是它们可能会在词的拆分中被删除。命令替换$(catfile)可以用等价但是更快的方法$(<file)代替。
当使用旧式的反引号("‘‘")替换形式时，反斜杠只有其字面意义，除非后面是$,‘,或者是\.第一个前面没有反斜杠的反引号将结束命令替换。当使用$(command)形式时，括号中所有字符组成了整个命令；没有被特殊处理的字符。
命令替换可以嵌套。要在使用反引号形式时嵌套，可以用反斜杠来转义内层的反引号。
如果替换发生在双引号之中，结果将不进行词的拆分和路径扩展。
ArithmeticExpansion
算术扩展允许算术表达式的求值和结果的替换。算术扩展的格式是：
$((expression))
表达式expression被视为如同在双引号之中一样，但是括号中的双引号不会被特殊处理。表达式中所有词都经过了参数扩展，字符串扩展，命令替换和引用的删除。算术替换可以嵌套。
求值根据下面算术求值(ARITHMETICEVALUATION)章节中列出的规则进行。如果表达式expression非法，bash输出错误提示消息，不会进行替换。
ProcessSubstitution
Processsubstitution(进程替换)只有在支持命名管道(FIFOs)，或者支持使用/dev/fd方式为打开的文件命名的系统中才可用。它的形式是<(list)或者是>(list)。进程list运行时的输入或输出被连接到一个FIFO或者/dev/fd中的文件。文件的名称作为一个参数被传递到当前命令，作为扩展的结果。如果使用>(list)形式，向文件写入相当于为list提供输入。如果使用<(list)形式，可以读作为参数传递的文件来获得list的输出。
如果可能的话，进程替换是与参数和变量扩展，命令替换和算术扩展同时发生的。
WordSplitting
shell检测不在双引号引用中发生的参数扩展，命令替换和算术扩展的结果，进行wordsplitting(词的拆分)。
shell将IFS的每个字符都作为定界符，根据这些字符来将其他扩展的结果分成词。如果IFS没有定义，或者它的值是默认的<space><tab><newline>,那么IFS字符的任何序列都将作为分界之用。如果IFS的值是默认之外的值，那么词开头和结尾的空白字符space和tab都将被忽略，只要空白字符在IFS的值之内(即，IFS包含空白字符)。任何在IFS之中但是不是IFS空白的字符，以及任何相邻的IFS空白字符，将字段分隔开来。IFS空白字符的序列也被作为分界符。如果IFS的值是空，不会发生词的拆分。
显式给出的空值参数(""或’’)将被保留。隐含的空值参数，来自于空值的参数扩展，如果没有引用则将被删除。如果空值的参数在双引号引用中扩展，结果是空值的参数，将被保留。
注意如果没有发生扩展，不会进行词的拆分。
PathnameExpansion
词的拆分之后，除非设置过−f选项，bash搜索每个词，寻找字符*,?,和[.如果找到了其中之一，那么这个词被当作一个pattern(模式)，被替换为匹配这个模式的文件名以字母顺序排列的列表。如果没有找到匹配的文件名，并且shell禁用了nullglob选项，这个词将不发生变化。如果设置了nullglob选项并且没有找到匹配，这个词将被删除。如果启用了nocaseglob选项，匹配时将不考虑字母的大小写。当模式用作路径名扩展时，字符‘‘.’’如果在一个名称的开始或者紧随一个斜杠之后，那么它必须被显式地匹配，除非设置了dotglobshell选项。当匹配一个路径名时，斜杠符必须被显式地匹配。其他情况下，字符‘‘.’’不会被特殊对待。参见下面的shell内建命令(SHELLBUILTINCOMMANDS)中对shopt的介绍，其中有shell选项nocaseglob,nullglob,和dotglob的描述。
环境变量GLOBIGNORE可以用来限制匹配pattern的文件名集合。如果设置了GLOBIGNORE，每个匹配的文件名如果匹配GLOBIGNORE中任何一个模式的话将从匹配的列表中删除。文件名‘‘.’’和‘‘..’’总是被忽略，即使设置了GLOBIGNORE。但是，设置GLOBIGNORE和启用shell选项dotglob效果是相同的，因此所有其他以‘‘.’’开头的文件名将被匹配。要得到原来的行为(忽略所有以‘‘.’’开头的文件名)，可以将‘‘.*’’添加为GLOBIGNORE的模式之一。选项dotglob被禁用，如果GLOBIGNORE没有定义时。
PatternMatching
任何模式中出现的字符，除了下面描述的特殊模式字符外，都匹配它本身。模式中不能出现NUL字符。如果要匹配字面上的特殊模式字符，它必须被引用。
特殊模式字符有下述意义：
*
匹配任何字符串包含空串。
?
匹配任何单个字符。
[...]
匹配所包含的任何字符之一。用一个连字符(‘-’)分隔的一对字符意思是一个rangeexpression(范围表达式)；任何排在它们之间的字符，包含它们，都被匹配。排序使用当前语言环境的字符顺序和字符集。如果[之后的第一个字符是一个!或是一个^那么任何不包含在内的字符将被匹配。范围表达式中字符的顺序是由当前语言环境和环境变量LC_COLLATE的值(如果设置了的话)决定的。一个−只有作为集合中第一个或最后一个字符时才能被匹配。一个]只有是集合中第一个字符时才能被匹配。
在[和]中，characterclasses(字符类)可以用[:class:]这样的语法来指定，这里class是在POSIX.2标准中定义的下列类名之一:
alnumalphaasciiblankcntrldigitgraphlowerprintpunctspaceupperwordxdigit
一个字符类匹配任何属于这一类的字符。word字符类匹配字母，数字和字符_。
在[和]中，可以用[=c=]这样的语法来指定equivalenceclass(等价类)。它匹配与字符c有相同归并权值(collationweight，由当前语言环境定义)的字符。
在[和]中，语法[.symbol.]匹配归并符号(collatingsymbol)symbol。
如果使用内建命令shopt启用了shell选项extglob，将识别另外几种模式匹配操作符。下面的描述中，pattern-list是一个或多个模式以|分隔的列表。复合的模式可以使用一个或多个下列的子模式构造出来：
?(pattern-list)
匹配所给模式零次或一次出现
*(pattern-list)
匹配所给模式零次或多次出现
+(pattern-list)
匹配所给模式一次或多次出现
@(pattern-list)
准确匹配所给模式之一
!(pattern-list)
任何除了匹配所给模式之一的字串
QuoteRemoval
经过前面的扩展之后，所有未引用的字符\,’,以及并非上述扩展结果的字符"都被删除。
重定向(REDIRECTION)

在命令执行前，它的输入和输出可能被redirected(重定向)，使用一种shell可以解释的特殊记法。重定向也可以用于为当前shell执行环境打开和关闭文件。下列重定向操作符可以前置或者放在simplecommand(简单命令)之中的任何位置，或者放在command之后。重定向是以出现的顺序进行处理的，从左到右。
下列描述中，如果文件描述符被忽略，并且第一个重定向操作符是<,那么重定向指的是标准输入(文件描述符是0)。如果重定向操作符的第一个字符是>,那么重定向指的是标准输出(文件描述符是1)。
下列描述中，重定向操作符之后的词如果没有特殊说明，都要经过braceexpansion,tildeexpansion,parameterexpansion,commandsubstitution,arithmeticexpansion,quoteremoval,pathnameexpansion,还有wordsplitting。如果扩展为多于一个词，bash将报错。
注意重定向的顺序非常重要。例如，命令
ls>dirlist2>&1
将标准输出和标准错误重定向到文件dirlist,而命令
ls2>&1>dirlist
只会将标准输出重定向到文件dirlist,因为在标准输出被重定向到文件dirlist中之前，标准错误被复制为标准输出。
一些文件名在重定向中被bash特殊处理，如下表所示：
/dev/fd/fd
如果fd是一个合法的整数，文件描述符fd将被复制。
/dev/stdin
文件描述符0被复制。
/dev/stdout
文件描述符1被复制。
/dev/stderr
文件描述符2被复制。
/dev/tcp/host/port
如果host是一个合法的主机名或Internet地址，并且port是一个整数端口号或服务名，bash试图建立与相应的socket(套接字)的TCP连接。
/dev/udp/host/port
如果host是一个合法的主机名或Internet地址，并且port是一个整数端口号或服务名，bash试图建立与相应的socket(套接字)的UDP连接。
打开或创建文件错误将导致重定向出错。
RedirectingInput
重定向输入使得以word扩展结果为名的文件被打开并通过文件描述符n读取，如果没有指定n那么就作为标准输入(文件描述符为0)读取。
重定向输入的一般形式是：
[n]<word
RedirectingOutput
重定向输出使得以word扩展结果为名的文件被打开并通过文件描述符n写入，如果没有指定n那么就作为标准输出(文件描述符为1)写入。
重定向的一般形式是：
[n]>word
如果重定向操作符是>，并且启用了内建命令set的noclobber选项，那么如果word扩展后得到的文件名存在并且是一个普通的文件，重定向将失败。如果重定向操作符是>|,或者重定向操作符是>并且没有启用内建命令set的noclobber选项，那么即使word得出的文件名存在，也会尝试进行重定向。
AppendingRedirectedOutput(添加到重定向后的输出尾部)
这种方式的输出重定向使得以word扩展结果为名的文件被打开并通过文件描述符n从尾部添加。如果没有指定n就使用标准输出(文件描述符1)。如果文件不存在，它将被创建。
重定向的一般形式是：
[n]>>word
RedirectingStandardOutputandStandardError
Bash允许使用这种结构将标准输出和标准错误(文件描述符1和2)重定向到以word扩展结果为名的文件中。
有两种重定向标准输出/标准错误的形式：
&>word
还有
>&word
两种形式中，推荐使用第一种。它与
>word2>&1
在语义上等价。
HereDocuments
这种重定向使得shell从当前源文件读取输入，直到遇到仅包含word的一行(并且没有尾部空白，trailingblanks)为止。直到这一点的所有行被用作命令的标准输入。
here-document的格式是：
<<[−]word
here-document
delimiter
不会对word进行parameterexpansion,commandsubstitution,arithmeticexpansion,或者pathnameexpansion。如果word中任何字符是引用的，delimiter将是对word进行引用删除的结果，here-document中的行不会被扩展。如果word没有被引用，here-documnet中的所有行都要经过parameterexpansion,commandsubstitution,和arithmeticexpansion。在后一种情况下，字符序列\<newline>被忽略；必须用\来引用字符\,$,和‘.
如果重定向操作符是<<−,那么所有前导的tab字符都被从输入行和包含delimiter的行中删除。这样使得shell脚本中的here-document可以被更好地缩进。
HereStrings
here-document的变种，形式是
<<<word
word被扩展，提供给命令作为标准输入。
DuplicatingFileDescriptors(复制文件描述符)
重定向操作符
[n]<&word
用于复制文件描述符。如果word扩展为一个或多个数字，n代表的文件描述符将成为那个文件描述符的复制。如果word中的数字并未指定一个被用于读取的文件描述符，将产生一个重定向错误。如果word扩展为−,文件描述符n将被关闭。如果没有指定n，将使用标准输入(文件描述符0)。
类似的，操作符
[n]>&word
用于复制输出文件描述符。如果没有指定n，将使用标准输出(文件描述符1)。如果word中的数字并未指定一个被用于输出的文件描述符，将产生一个重定向错误。特殊情况下，如果忽略了n，并且word并非扩展为一个或多个数字，标准输出和标准错误将被重定向，和前面描述的一样。
MovingFileDescriptors
重定向操作符
[n]<&digit−
将文件描述符digit移动为文件描述符n,或标准输入(文件描述符0)，如果没有指定n的话。digit复制为n之后就被关闭了。
类似的，重定向操作符
[n]>&digit−
将文件描述符digit移动为文件描述符n,或标准输出(文件描述符1)，如果没有指定n的话。
OpeningFileDescriptorsforReadingandWriting
重定向操作符
[n]<>word
使得以word扩展结果为名的文件被打开，通过文件描述符n进行读写。如果没有指定n那么就使用文件描述符0。如果文件不存在，它将被创建。
别名(ALIASES)

Aliases(别名机制)允许将一个词来替换为一个字符串，如果它是一个简单命令的第一个词的话。shell记录着一个别名列表，可以使用内建命令alias和unalias来定义和取消(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节)。每个命令的第一个词，如果没有引用，都将被检查是否是一个别名。如果是，这个词将被它所指代的文本替换。别名和替换的文本可以包含任何有效的shell输入，包含上面列出的metacharacters(元字符)，特殊情况是别名中不能包含=。替换文本的第一个词也被检查是否是别名，但是如果它与被替换的别名相同，就不会再替换第二次。这意味着可以用ls作为ls−F的别名，bash不会递归地展开替换文本。如果别名的最后一个字符是blank,那么命令中别名之后的下一个词也将被检查是否能进行别名展开。
别名可以使用alias命令来创建或列举出来，使用unalias命令来删除。
在替换文本中没有参数机制。如果需要参数，应当使用shell函数(参见下面的FUNCTIONS(函数)段落)。
如果shell不是交互的，别名将不会展开，除非使用内建命令shopt设置了expand_aliases选项。
关于别名的定义和使用中的规则比较混乱。Bash在执行一行中的任何命令之前，总是读入至少完整一行的输入。别名在命令被读取时展开，而不是在执行的时候。因此，别名定义如果和另一个命令在同一行，那么不会起作用，除非读入了下一行。别名定义之后，同一行中的命令不会受新的别名影响。这种行为在函数执行时存在争议，因为别名替换是在函数定义被读取时发生的，而不是函数被执行的时候，因为函数定义本身是一个复合命令。结果，在函数中定义的别名只有当这个函数执行完才会生效。为了保险起见，应当总是将别名定义放在单独的一行，不在复合命令中使用alias。
不管什么情况下，别名都被shell函数超越(besuperseded)。
函数(FUNCTIONS)

一个shell函数，以上面SHELLGRAMMAR中描述的方法定义，保存着一系列的命令，等待稍后执行。当shell函数名作为一个简单命令名使用时，这个函数名关联的命令的序列被执行。函数在当前shell的上下文环境中执行；不会创建新的进程来解释它们(这与shell脚本的执行形成了对比)。当执行函数时，函数的参数成为执行过程中的位置参数(positionalparameters)。特殊参数#被更新以反映这个变化。位置参数0不会改变。函数执行时，FUNCNAME变量被设置为函数的名称。函数和它的调用者在shell执行环境的所有其他方面都是一样的，特殊情况是DEBUG陷阱(参见下面对内建函数trap的描述，在shell内建命令(SHELLBUILTINCOMMANDS)章节中)不会被继承，除非函数设置了trace属性(参见下面对内建函数declare的描述)。
函数中的局部变量可以使用内建命令local来声明。通常情况下，变量和它们的值在函数和它的调用者之间是共享的。
如果函数中执行了内建命令return，那么函数结束，执行从函数调用之后的下一个命令开始。函数结束后，位置参数的值以及特殊参数#都将重置为它们在函数执行前的值。
函数名和定义可以使用内建命令declare或typeset加上−f参数来列出。如果在declare或typeset命令中使用−F选项将只列出函数名。函数可以使用内建命令export加上−f参数导出，使得子shell中它们被自动定义。
函数可以是递归的。对于递归调用的次数没有硬性限制。
算术求值("ARITHMETICEVALUATION")

在一定的环境下，shell允许进行算术表达式的求值(参见内建命令let和ArithmeticExpansion(算术表达式))。求值使用固定宽度的整数，不检查是否溢出，但是被零除会被捕获，标记为错误。操作数及其优先级和聚合程度与C语言中相同。下列操作数的列表按照相同优先级的操作数其级别来分组。列出的级别顺序是优先级递减的。
id++id−−
变量自增/自减(在后)
++id−−id
变量自增/自减(在前)
−+
(单目的)取负/取正
!~
逻辑和位取反
**
乘幂
*/%
乘，除，取余
+−
加，减
<<>>
左/右位移
<=>=<>
比较
==!=
相等/不等
&
位与(AND)
^
位异或(exclusiveOR)
|
位或(OR)
&&
逻辑与(AND)
||
逻辑或(OR)
expr?expr:expr
条件求值
=*=/=%=+=−=<<=>>=&=^=|=
赋值
expr1,expr2
逗号表达式
shell变量可以作为操作数；在表达式求值之前会进行参数扩展。在表达式中，可以用名称引用shell变量，不必使用参数扩展的语法。变量被引用时，其值被作为算术表达式来求值。shell变量用于表达式中时，不必启用整数属性。
以0为前导的常量被当作八进制数，以0x或0X作为前导表明是十六进制。其他情况下，数字的形式是[base#]n，这里base是一个2到64的十进制数值，作为数字的基数，n是在这个基数中数字的值。如果忽略了base#，将以10为基数。大于10的数字依次以小写字母，大写字母，@和_表示。如果base小于或等于36，在表示10与35之间的数字时小写字母和大写字母可以互换。
操作符根据优先级顺序进行求值。圆括号中的子表达式被最先求值，可能会超越上面的优先级规则。
条件表达式("CONDITIONALEXPRESSIONS")

条件表达式用于[[复合命令以及内建命令test和[中，用来测试文件属性，进行字符串和算术比较。表达式使用下面的单目或二进制操作构造。如果某操作的任何file参数的形式是/dev/fd/n，那么将检查文件描述符n。如果某操作的file参数是/dev/stdin，/dev/stdout或者/dev/stderr之一，将分别检查文件描述符0，1和2。
−afile
如果file存在则为真。
−bfile
如果file存在且为块设备则为真。
−cfile
如果file存在且为字符设备则为真。
−dfile
如果file存在且是一个目录则为真。
−efile
如果file存在则为真。
−ffile
如果file存在且为普通文件则为真。
−gfile
如果file存在且是设置组ID的(sgid)则为真。
−hfile
如果file存在且为符号链接则为真。
−kfile
如果file存在且设置了‘‘sticky’’位(粘滞位)则为真。
−pfile
如果file存在且是一个命名管道(FIFO)则为真。
−rfile
如果file存在且可读则为真。
−sfile
如果file存在且大小大于零则为真。
−tfd
如果文件描述符fd是打开的且对应一个终端则为真。
−ufile
如果file存在且是设置用户ID的(suid)则为真。
−wfile
如果file存在且可写则为真。
−xfile
如果file存在且可执行则为真。
−Ofile
如果file存在且为有效用户ID所拥有则为真。
−Gfile
如果file存在且为有效组ID所拥有则为真。
−Lfile
如果file存在且为符号链接则为真。
−Sfile
如果file存在且为套接字则为真。
−Nfile
如果file存在且上次读取后被修改过则为真。
file1−ntfile2
如果file1比file2要新(根据修改日期)，或者如果file1存在而file2不存在，则为真。
file1−otfile2
如果file1比file2更旧，或者如果file1不存在而file2存在，则为真。
file1−effile2
如果file1和file2指的是相同的设备和inode号则为真。
−ooptname
如果启用了shell选项optname则为真。参见下面对内建命令set的−o选项的描述中的选项列表。
−zstring
如果string的长度为0则为真。
−nstring
string
如果string的长度非0则为真。
string1==string2
如果字符串相等则为真。=可以用于使用==的场合来兼容POSIX规范。
string1!=string2
如果字符串不相等则为真。
string1<string2
如果string1在当前语言环境的字典顺序中排在string2之前则为真。
string1>string2
如果string1在当前语言环境的字典顺序中排在string2之后则为真。
arg1OParg2
OP是−eq,−ne,−lt,−le,−gt,或−ge之一。这些算术二进制操作返回真，如果arg1与arg2分别是相等，不等，小于，小于或等于，大于，大于或等于关系。Arg1和arg2可以是正/负整数。
简单命令扩展("SIMPLECOMMANDEXPANSION")

当执行一个简单命令时，shell进行下列扩展，赋值和重定向，从左到右。
1.
解释器标记为与变量赋值(在命令名之前的)和重定向有关的词被保存等待随后处理。
2.
并非变量赋值或重定向的词被扩展。如果扩展后仍然有词保留下来，第一个词被作为命令名，其余词是参数。
3.
重定向按照上面REDIRECTION中讲到的规则进行。
4.
每个变量赋值中=之后的文本在赋予变量之前要经过波浪线扩展，参数扩展，命令替换，算术扩展和引用删除。
如果没有得到命令名，变量赋值影响当前shell环境。否则，变量被加入被执行的命令的环境中，不影响当前shell环境。如果任何赋值动作试图为只读变量赋值，将导致出错，命令以非零状态值退出。
如果没有得到命令名，重定向仍会进行，但是不影响当前shell环境。重定向出错将使命令以非零状态值退出。
如果扩展后有命令名保留下来，那么执行过程如下所示。否则，命令退出。如果在任何扩展中包含命令替换，那么整个命令的退出状态是最后一个命令替换的退出状态。如果没有进行命令替换，命令以状态零退出。
命令执行(COMMANDEXECUTION)

命令被拆分为词之后，如果结果是一个简单命令和可选的参数列表，将执行下面的操作。
如果命令名中没有斜杠，shell试图定位命令位置。如果存在同名的shell函数，函数将被执行，像上面FUNCTIONS中讲到的一样。如果名称不是一个函数，shell从内建命令中搜索它。如果找到对应命令，它将被执行。
如果名称既不是shell函数也不是一个内建命令，并且没有包含斜杠，bash搜索PATH的每个成员，查找含有此文件名(可执行文件)的目录。Bash使用散列表来储存可执行文件的全路径(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)中的hash。只有在散列表中没有找到此命令，才对PATH进行完整的搜索。如果搜索不成功，shell输出错误消息，返回退出状态127。
如果搜索成功，或者命令中包含一个或多个斜杠，shell在单独的执行环境中执行这个程序。参数0被设置为所给名称；命令的其他参数被设置为所给的参数，如果有的话。
如果执行失败，因为文件不是可执行格式，并且此文件不是目录，就假定它是一个shellscript(脚本)，一个包含shell命令的文件。此时将孵化(spawn)出一个子shell来执行它。子shell重新初始化自身，效果就好像是执行了一个新的shell来处理脚本一样，但是父shell保存的命令位置仍然被保留(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)中的hash)。
如果程序是以#!开头的文件，那么第一行的其余部分指定了这个程序的解释器。shell执行指定的解释器，如果操作系统不会自行处理这种可执行文件格式的话。解释器的参数由下面三部分组成：程序第一行中解释器名称之后的可选的一个参数，程序的名称，命令行参数，如果有的话。
命令执行环境(COMMANDEXECUTIONENVIRONMENT)

shell有executionenvironment(执行环境)的概念，由下列内容组成：
•
shell启动时继承的打开的文件，例如在内建命令exec中使用重定向修改的结果
•
当前工作目录，使用cd，pushd或者popd设置，或是由shell在启动时继承得到
•
文件创建模式掩码，使用umask设置或是从shell的父进程中继承得到
•
当前陷阱，用trap设置
•
shell参数，使用变量赋值或者set设置，或者是从父进程的环境中继承得到
•
shell函数，在执行中定义或者是从父进程的环境中继承得到
•
设为允许的选项，在执行时设置(要么是默认允许的，要么是命令行给出的)或者是用set设置
•
用shopt设为允许的选项
•
用alias定义的shell别名
•
各种进程号，包含后台作业的进程号，$$的值，以及$PPID的值
当并非shell函数或内置命令的简单命令执行时，它在一个由下述内容组成的单独的执行环境中启动。除非另外说明，值都是从shell中继承的。
•
shell打开的文件，加上对命令使用重定向修改和添加的文件
•
当前工作目录
•
文件创建模式掩码
•
标记为导出(export)的shell变量，以及传递到环境中为这个命令导出的变量
•
shell捕捉的陷阱被重置为从shell的父进程中继承的值，shell忽略的陷阱也被忽略
在单独的环境中启动的命令不能影响shell的执行环境。
命令替换和异步命令都在子shell环境中执行。子shell环境是原有shell环境的赋值，但shell捕捉的陷阱被重置为shell启动时从父进程中继承的值。作为管道一部分来执行的内建命令也在一个子shell环境中执行。对子shell环境所作修改不能影响到原有shell的执行环境。
如果命令后面是&并且没有启用作业控制，命令的默认标准输入将是空文件/dev/null。否则，被执行的命令从调用它的shell中继承被重定向修改的文件描述符。
环境(ENVIRONMENT)

当一个程序执行时，它被赋予一个字符串数组，成为环境environment。它是一个名称-值对(name−value)的列表，形式是name=value.
shell提供了多种操作环境的方法。启动时，shell扫描自身的环境，为每个找到的名字创建一个参数，自动地将它标记为export(向子进程导出的)。被执行的命令继承了这个环境。export和declare−x命令允许参数和函数被加入到环境中或从环境中删除。如果环境中参数的值被修改，新值成为环境的一部分，替换了旧值。所有被执行的命令继承的环境包含shell的初始环境(可能值被修改过)，减去被unset命令删除的，加上通过export和declare−x命令添加的部分。
可以在任何simplecommand或函数的环境中设定暂时有效的参数，只要将参数赋值放在命令前面就可以了，参见上面PARAMETERS的描述。这些赋值语句只在这个命令的环境中有效。
如果设置了内建命令set的−k选项，所有的变量赋值都将放到命令的环境中，不仅是在命令名前面的那些。
当bash执行一个外部命令时，变量_被设置为命令的文件全名，然后被传递到命令的环境之中。
退出状态("EXITSTATUS")

从shell的角度看，一个命令退出状态是0意味着成功退出。退出状态是0表明成功。非零状态值表明失败。当命令收到fatalsignalN退出时，bash使用128+N作为它的退出状态。
如果没有找到命令，为执行它而创建的子进程返回127。如果找到了命令但是文件不可执行，返回状态是126。
如果命令由于扩展或重定向错误而失败，退出状态大于零。
shell内建命令如果成功返回0(true)，执行时出错则返回非零(false)。所有内建命令返回2来指示不正确的用法。
Bash自身返回最后执行的命令的退出状态，除非发生了语法错误，这时它返回非零值。参见下面的内建命令exit。
信号(SIGNALS)

如果bash是交互的，没有设定任何陷阱，它忽略SIGTERM(这样kill0不会杀掉交互的shell)。SIGINT被捕获并处理(从而使内建命令wait可以中断)。在所有情况下，bash忽略SIGQUIT。如果正在使用作业控制，bash忽略SIGTTIN,SIGTTOU,和SIGTSTP.
bash开始的并行作业的信号处理句柄都设置为shell从父进程中继承的值。如果不是正在使用作业控制，异步命令还忽略SIGINT和SIGQUIT。作为命令替换结果运行的命令忽略键盘产生的作业控制信号SIGTTIN,SIGTTOU,和SIGTSTP.
如果收到信号SIGHUP，shell默认退出。在退出前，交互的shell向所有作业，运行的或停止的，发送SIGHUP信号。shell向停止的作业发出SIGCONT信号来保证它们会收到SIGHUP.要阻止shell向特定的作业发送信号，应当使用内建命令disown将作业从作业表中删除(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节)或者使用disown−h来标记为不接受SIGHUP。
如果使用shopt设置了shell选项huponexit，在交互的登录shell退出时bash向所有作业发出SIGHUP信号。
当bash等待命令执行结束时，如果收到已设置了陷阱的信号，陷阱(trap)将不会执行，直到命令结束。当bash通过内建命令wait等待异步命令时，如果收到已设置了陷阱的信号，将使得内建命令wait立即以大于128的状态值返回。接着，陷阱将立即被执行。
作业控制("JOBCONTROL")

Jobcontrol(作业控制)指的是可以选择停止(suspend，挂起)进程执行，并且可以在之后继续(resume，恢复)执行的能力。用户一般在交互的人机界面中使用这种功能。界面是由系统的终端驱动和bash共同提供的。
shell将每个管道分配给一个作业(job)。它保存一个当前运行的作业表，可以用jobs命令来列出。当bash启动一个异步的作业时(background，后台执行)，它输出这样的一行：
[1]25647
表明这个作业的作业号是1，与作业相关连的管道中最后一个进程的进程ID是15647。管道中所有进程都是同一个作业的成员。Bash使用作业(job)概念作为作业控制的基础。
为简化作业控制的用户界面的实现，操作系统负责管理“当前终端的进程组”(currentterminalprocessgroupID)的概念。这个进程组的成员(进程组ID是当前终端进程组ID的进程)可以收到键盘产生的信号，例如SIGINT.这些进程被称为foreground(前台的)。Background(后台的)进程是那些进程组ID与终端不同的进程；这些进程不会收到键盘产生的信号。只有前台进程可以从终端读或向终端写。后台进程试图读/写终端时，将收到终端驱动程序发送的SIGTTIN(SIGTTOU)信号。这个信号如果没有加以捕捉，将挂起这个进程。
如果bash运行其上的操作系统支持作业控制，bash会包含使用它的设施。在一个进程正在运行的时候键入suspend挂起字符(通常是^Z,Control-Z)将使这个进程暂停，将控制权还给bash.输入delayedsuspend,延时挂起字符(通常是^Y,Control-Y)将使这个进程在试图从终端读取输入时暂停，将控制权还给bash.用户接下来可以控制此作业的状态，使用bg命令使它在后台继续运行，fg命令使它在前台继续运行，或kill命令将它杀死。^Z会立即起作用，并且还有使等待中的(pending)输出和输入被忽略的附加副作用。
有很多方法来指代shell中的作业。字符%可以引入作业名。编号为n的作业可以用%n的形式来指代。作业也可以用启动它的名称的前缀，或者命令行中的子字符串来指代。例如，%ce指代一个暂停的ce作业。如果前缀匹配多于一个作业，bash报错。另一方面，使用%?ce,可以指代任何命令行中包含字符串ce的作业。如果子字符串匹配多于一个作业，bash报错。符号%%和%+指代shell意义上的currentjob，当前作业，也就是前台被暂停的最后一个作业，或者是在后台启动的作业。previousjob，前一作业可以使用%−来指代。在有关作业的输出信息中(例如，命令jobs的输出)，当前作业总是被标记为+,前一作业标记为−.
简单地给出作业名，可以用来把它放到前台：%1是‘‘fg%1’’的同义词，将作业1从后台放到前台。类似的，‘‘%1&’’在后台恢复作业1，与‘‘bg%1’’等价。
当某个作业改变状态时，shell立即可以得知。通常，bash等待直到要输出一个提示符时，才会报告作业的状态变化，从而不会打断其他输出。如果启用了内建命令set的−b选项，bash将立即报告这些变化。对SIGCHLD信号的陷阱将在每个子进程退出时执行。
如果在作业暂停时试图退出bash，shell打印一条警告消息。命令jobs可能被用来检查作业的状态。如果再次试图退出，中间没有其他命令，shell不会打印其他警告，暂停的作业将终止。
提示符(PROMPTING)

在交互执行时，bash在准备好读入一条命令时显示主提示符PS1，在需要更多的输入来完成一条命令时显示PS2。Bash允许通过插入一些反斜杠转义的特殊字符来定制这些提示字符串，这些字符被如下解释：
\a
一个ASCII响铃字符(07)
\d
日期，格式是"星期月份日"(例如，"TueMay26")
\D{format}
format被传递给strftime(3)，结果被插入到提示字符串中；空的format将使用语言环境特定的时间格式。花括号是必需的
\e
一个ASCII转义字符(033)
\h
主机名，第一个‘.’之前的部分
\H
主机名
\j
shell当前管理的作业数量
\l
shell的终端设备名的基本部分
\n
新行符
\r
回车
\s
shell的名称，$0的基本部分(最后一个斜杠后面的部分)
\t
当前时间，采用24小时制的HH:MM:SS格式
\T
当前时间，采用12小时制的HH:MM:SS格式
\@
当前时间，采用12小时制上午/下午(am/pm)格式
\A
当前时间，采用24小时制上午/下午格式
\u
当前用户的用户名theusernameofthecurrentuser
\v
bash的版本(例如，2.00)
\V
bash的发行编号，版本号加补丁级别(例如，2.00.0)
\w
当前工作目录
\W
当前工作目录的基本部分
\!
此命令的历史编号
\#
此命令的命令编号
\$
如果有效UID是0，就是#,其他情况下是$
\nnn
对应八进制数nnn的字符
\\
一个反斜杠
\[
一个不可打印字符序列的开始，可以用于在提示符中嵌入终端控制序列
\]
一个不可打印字符序列的结束
命令编号和历史编号通常是不同的：历史编号是命令在历史列表中的位置，可能包含从历史文件中恢复的命令(参见下面的HISTORY历史章节)，而命令编号是当前shell会话中执行的命令序列中，命令的位置。字符串被解码之后，它将进行扩展，要经过parameterexpansion,commandsubstitution,arithmeticexpansion和quoteremoval,最后要经过shell选项promptvars处理(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节中，对命令shopt的描述)。
readline库(READLINE)

这是在交互shell中处理读取输入的库，除非在shell启动时给出了−−noediting选项。默认情况下，行编辑命令类似于emacs中的那些。也可以使用vi样式的行编辑界面。要在shell运行之后关闭行编辑，使用内置命令set的+oemacs或+ovi选项(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节)。
ReadlineNotation
在这个小节中，将使用emacs样式的记法来表述按键。Ctrl键记为C−key，例如，C−n意思是Ctrl−N。类似的，meta键记为M−key，因此M−x意味着Meta−x。(在没有meta键的键盘上，M−x意思是ESC−x，也就是说，按下Esc键，然后按x键。这使得Esc成为metaprefix。M−C−x的组合意思是Esc−Ctrl−x，也就是按Esc键，然后按住Ctrl键，同时按x键。)
readline命令可以有数字的参数(arguments)，一般作为重复的计数。有些时候，它是重要参数的标记。给向前方进行的命令(例如，kill−line)传递负数参数，将使得命令向反方向进行。下面的命令如果接受参数时的行为与此不同，将另行说明。
当命令被描述为剪切(killing)文本时，被删除的文本被保存，等待将来使用(粘贴，yanking)。被剪切的文本保存在killring中。连续的剪切使得文本被依次加入到一个单元中，可以一次被粘贴。不剪切文本的命令将killring中的文本分离。
ReadlineInitialization初始化
readline可以通过将命令放入初始化文件(inputrc文件)来定制。文件名从变量INPUTRC的值中获取。如果没有设置这个变量，默认是~/.inputrc.当使用readline库的程序启动时，将读取初始化文件，按键关联和变量将被设置。readline初始化文件中只允许有很少的基本构造。空行被忽略。以#开始的行是注释。以$开始的行指示了有条件的构造。其他行表示按键关联和变量设置。
默认的按键关联可以使用inputrc文件改变。其他使用这个库的程序可以添加它们自己的命令和关联。
例如，将
M−Control−u:universal−argument
或
C−Meta−u:universal−argument
放入inputrc将使得M−C−u执行readline命令universal−argument.
可以识别下列字符的符号名称：RUBOUT,DEL,ESC,LFD,NEWLINE,RET,RETURN,SPC,SPACE,和TAB.
在命令名之外，readline允许将按键与一个字符串关联，当按下这个键时，将插入这个字符串(一个宏，macro)。
ReadlineKeyBindings
inputrc文件中的控制按键关联的语法非常简单。需要的内容是命令名或宏，以及它应当关联到的按键序列。名称可以以两种方式指定：一个按键的符号名称，可能带有Meta−或Control−前缀，或者是一个按键序列。
当使用keyname:function−name或macro形式时，keyname是按键以英文拼写的名称。例如：
Control-u:universal−argument
Meta-Rubout:backward-kill-word
Control-o:">output"
在上述例子中，C−u被关联到函数universal−argument,M−DEL被关联到函数backward−kill−word,而C−o被关联为运行右边给出的宏(意思是，将向行中插入‘‘>output’’)。
在第二种形式中，"keyseq":function−name或macro，keyseq不同于上面的keyname，表示整个按键序列的字符串可以通过将按键序列放在双引号引用中来指定。可以使用一些GNUEmacs样式的按键序列，如下例所示，但是不会识别按键的符号名称。
"\C−u":universal−argument
"\C−x\C−r":re−read−init−file
"\e[11~":"FunctionKey1"
在上述例子中，C−u被又一次关联到函数universal−argument.C−xC−r被关联到函数re−read−init−file,而ESC[11~被关联为插入文本‘‘FunctionKey1’’.
GNUEmacs样式的转义序列的全集为：
\C−
Ctrl前缀
\M−
Meta前缀
\e
一个Esc字符
\\
反斜杠
\"
字面上的"
\’
字面上的’
除了GNUEmacs样式的转义序列，还有一系列反斜杠转义序列可用：
\a
响铃
\b
回退
\d
删除
\f
进纸
\n
新行符
\r
回车
\t
水平跳格
\v
竖直跳格
\nnn
一个八比特字符，它的值是八进制值nnn(一到三个八进制数字)。
\xHH
一个八比特字符，它的值是十六进制值HH(一到两个十六进制数字)。
输入宏的文本时，必须使用单引号或双引号引用来表明是宏的定义。没有引用的文本被当作函数名。在宏的定义体中，上述反斜杠转义被扩展。反斜杠将引用宏文本中所有其他字符，包括"和’。
Bash允许使用内建命令bind来显示和修改当前readline按键关联。在交互使用中可以用内建命令set的−o选项切换到编辑模式(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节)。
ReadlineVariables
readline包含额外的可用于定制它的行为的变量。可以在inputrc文件中设置变量，使用如下形式的语句：
setvariable−namevalue
除非另外说明，readline变量的值总是On或Off。变量和它们的默认值是：
bell−style(audible)
控制了当readline需要鸣终端响铃时的动作。如果设置为none，readline不会鸣铃。如果设置为visible，readline使用可视的响铃，如果可用的话。如果设置为audible，readline试着鸣终端响铃。
comment−begin(‘‘#’’)
这个字符串在执行readline命令insert−comment时被插入。这个命令在emacs模式下被关联为M−#，在vi模式下是#。
completion−ignore−case(Off)
如果设置为On，readline进行大小写不敏感的文件名匹配和补全。
completion−query−items(100)
这个变量决定着何时向用户询问，是否查看由命令possible−completions产生的可能的补全数量。它可以设为任何大于或等于0的值。如果可能的补全数量大于或等于这个变量的值，用户将被提示是否愿意查看它们；否则将直接在终端上列出它们。
convert−meta(On)
如果设置为On，readline将把设置了最高位的字符转换为ASCII按键序列，方法是去掉第八位，前缀一个转义字符(实际上，使用Esc作为转义符metaprefix)。
disable−completion(Off)
如果设置为On，readline将禁止词的补全。补全字符将被插入到行中，就好像它们被映射为self-insert。
editing−mode(emacs)
控制readline的按键关联集合与emacs还是vi相似。editing−mode可以设置为emacs或vi。
enable−keypad(Off)
如果设置为On，readline在调用时将试图启用辅助键盘。一些系统需要设置这个来启用方向键。
expand−tilde(Off)
如果设置为On，readline试图进行词的补全时会进行波浪线扩展。
history-preserve-point
如果设置为On，历史代码试着在previous-history或next-history取回的每个历史行的相同位置中加点。
horizontal−scroll−mode(Off)
如果设置为On，将使得readline使用单行来显示，如果它比屏幕宽度要长，就在单一的屏幕行上水平滚动输入行，而不是自动回绕到新行。
input−meta(Off)
如果设置为On，readline将允许八比特输入(也就是说，它不会将它读入的字符中最高位删除)，不管它能支持什么样的终端要求。名称meta−flag与此变量同义。
isearch−terminators(‘‘C−[C−J’’)
用于终止增量的搜索，不再将字符当作命令执行的字符串。如果这个变量没有赋值，字符串Esc和C−J将终止增量的搜索。
keymap(emacs)
设置当前readline键盘映射。有效的键盘映射名称是emacs,emacs−standard,emacs−meta,emacs−ctlx,vi,vi−command，还有vi−insert。vi等价于vi−command;emacs等价于emacs−standard。默认值是emacs;editing−mode的值也会影响默认的键盘映射。
mark−directories(On)
如果设置为On，补全的目录名会添加一个斜杠。
mark−modified−lines(Off)
如果设置为On，已被修改的历史行将显示为前缀一个星号(*)。
mark−symlinked−directories(Off)
如果设置为On，补全的名称如果是到目录的符号链接，则将添加一个斜杠(与mark−directories的值同样处理)。
match−hidden−files(On)
这个变量，如果设置为On，将使得readline在进行文件名补全时，匹配以‘.’开头的文件(隐藏文件)，除非用户在要补全的文件名中给出了前导的‘.’。
output−meta(Off)
如果设置为On，readline将直接显示设置了第八位的字符，而不是转化为一个带meta前缀的转义序列。
page−completions(On)
如果设置为On，readline将使用内建的类似more的分页程序，来每次显示一屏可能的补全。
print−completions−horizontally(Off)
如果设置为On，readline将匹配的补全按字母表顺序排序，然后水平排列显示出来，而不是在屏幕上竖直排列显示。
show−all−if−ambiguous(Off)
这将调整补全函数的默认行为。如果设置为on,拥有多于一个可能的补全的词将立即列出所有匹配，而不是鸣响铃。
visible−stats(Off)
如果设置为On，在列出可能的补全时，将在文件名后面添加一个表示文件类型的字符，文件类型由stat(2)报告。
ReadlineConditionalConstructs
readline实现了一种功能，本质上与C预处理器进行条件编译的功能类似，允许根据测试的结果进行键盘关联和变量设置。其中使用了四种解释器指令。
$if
$if结构允许根据编辑模式，正在使用的终端，使用readline的应用程序来设定按键关联。测试的文本包括一行，直到行尾；不必用字符来隔离它。
mode
$if结构的mode=形式用于测试readline处于emacs还是vi模式。这可以与命令setkeymap结合使用，例如，设置emacs−standard和emacs−ctlx键盘映射，仅当readline以emacs模式启动。
term
term=形式用于包含与终端相关的按键关联，也许是将按键序列输出与终端的功能键相关联。等号=右边的词被同终端的全名和名称中第一个−前面的一部分相比较。例如，允许sun同时匹配sun和sun−cmd。
application
application结构用于包含应用程序相关的设置。每个使用readline的程序都设置applicationname，初始化文件可以测试它的值。它可用于将一个按键序列与对特定的程序有用的功能相关联。例如，下列命令添加了一个按键序列，用以引用bash中当前的词或前一个词
$ifBash
#Quotethecurrentorpreviousword
"\C−xq":"\eb\"\ef\""
$endif
$endif
上例中的这个命令，结束了一个$if命令。
$else
如果测试失败，$if指令中这个分支的命令将被执行。
$include
这个指令使用单个文件名作为参数，从文件中读取命令和按键关联。例如，下列指令将读取/etc/inputrc：
$include/etc/inputrc
Searching
readline提供了从命令历史中搜索包含给定字符串的行的命令(参见下面的HISTORY历史章节)。有两种搜索模式：incremental和non-incremental.
增量的搜索在用户结束输入搜索字符串时开始。在搜索字符串的每个字符被输入的同时，readline显示与已输入的字符串匹配的下一个历史条目。增量的搜索只要求输入能找到期望的历史条目所需的那么多字符。isearch-terminators变量中的字符用来终止一次增量的搜索。如果这个变量没有被赋值，Esc和Ctrl-J字符串将结束一次增量的搜索。Ctrl-G将取消一次增量的搜索，恢复初始的行。当搜索终止时，包含搜索字符串的历史条目成为当前行。
要从历史列表中找到其他匹配的条目，适当地键入Ctrl-S或Ctrl-R。这样将在历史中向前/向后搜索下一个匹配已输入的搜索字符串的条目。其他关联到某个readline命令的按键序列将终止搜索并执行关联的命令。例如，newline将终止搜索，接受当前行，从而执行历史列表中的命令。
readline可以记住上次增量搜索的字符串。如果键入两次Ctrl-R，中间没有输入任何字符来定义一个新的搜索字符串，那么将使用已记住的搜索字符串。
非增量的搜索将整个搜索字符串读入，然后才开始搜索匹配的历史条目。搜索字符串可以由用户输入，或者是当前行的内容的一部分。
ReadlineCommandNames
下面列出的是命令的名称以及默认情况下它们关联的按键序列。命令名称如果没有对应的按键序列，那么默认是没有关联的。在下列描述中，点(point)指当前光标位置，标记(mark)指命令set−mark保存的光标位置。point和mark之间的文本被称为范围(region)。
CommandsforMoving移动
beginning−of−line(C−a)
移动到当前行的开始。
end−of−line(C−e)
移动到当前行的结尾。
forward−char(C−f)
向前移动一字。
backward−char(C−b)
向后移动一字。
forward−word(M−f)
向前移动到下一词尾。词由字符(字母和数字)组成。
backward−word(M−b)
向后移动到当前或上一词首。
clear−screen(C−l)
清除屏幕，保留当前行在屏幕顶端。有参数时，刷新当前行，不清屏。
redraw−current−line
刷新当前行。
CommandsforManipulatingtheHistory操纵历史行
accept−line(Newline,Return)
接受这一行，不管光标在什么位置。如果行非空，将根据变量HISTCONTROL的状态加入到历史列表中。如果行是修改过的历史行，将恢复该历史行到初始状态。
previous−history(C−p)
从历史列表中取得前一个命令，从列表中向后移动。
next−history(C−n)
从历史列表中取得后一个命令，从列表中向前移动。
beginning−of−history(M−<)
移动到历史中的第一行。
end−of−history(M−>)
移动到输入历史行的末尾，也就是当前输入的行的末尾。
reverse−search−history(C−r)
从当前行开始向后搜索，按照需要在历史中向“上”移动。这是一个增量的搜索。
forward−search−history(C−s)
从当前行开始向前搜索，按照需要在历史中向“下”移动。这是一个增量的搜索。
non−incremental−reverse−search−history(M−p)
从当前行开始向后，使用非增量搜索来查找用户给出的字符串。
non−incremental−forward−search−history(M−n)
从当前行开始向前，使用非增量搜索来查找用户给出的字符串。
history−search−forward
从当前行开始向前搜索历史，查找从当前行首到point之间的字符串。这是一个非增量的搜索。
history−search−backward
从当前行开始向后搜索历史，查找从当前行首到point之间的字符串。这是一个非增量的搜索。
yank−nth−arg(M−C−y)
将前一个命令的第一个参数(通常是上一行的第二个词)插入到point位置。有参数n时，将前一个命令的第n个词(前一个命令中的词从0开始计数)插入到point位置。负数参数则插入前一个命令倒数第n个词。
yank−last−arg(M−.,M−_)
插入前一个命令的最后一个参数(上一历史条目的最后一个词)。有参数时，行为类似于yank−nth−arg。后继的yank−last−arg调用将从历史列表中向后移动，依次将每行的最后一个参数插入。
shell−expand−line(M−C−e)
扩展行，像shell做的那样。其中包含别名和历史扩展，还有所有的shell词的扩展。参见下面的HISTORYEXPANSION中关于历史扩展的描述。
history−expand−line(M−^)
在当前行进行历史扩展。参见下面的HISTORYEXPANSION中关于历史扩展的描述。
magic−space
在当前行进行历史扩展，并插入一个空格。参见下面的HISTORYEXPANSION中关于历史扩展的描述。
alias−expand−line
在当前行进行别名扩展，参见上面的ALIASES中关于别名扩展的描述。
history−and−alias−expand−line
在当前行进行历史和别名扩展。
insert−last−argument(M−.,M−_)
与yank−last−arg同义。
operate−and−get−next(C−o)
接受当前行，加以执行，从历史中取出相对当前行的下一行进行编辑。任何参数都被忽略。
edit−and−execute−command(C−xC−e)
启动一个编辑器，编辑当前命令行，将结果作为shell命令运行。Bash将依次试着运行$FCEDIT,$EDITOR,和emacs作为编辑器。
CommandsforChangingText改变文本
delete−char(C−d)
删除point处的字符。如果point在行首，行中没有字符，最后一次输入的字符没有被关联到delete−char，将返回EOF.
backward−delete−char(Rubout)
删除光标之后的字符。当给出一个数值的参数时，保存删除的文本到killring中。
forward−backward−delete−char
删除光标下的字符，除非光标在行尾，此时删除光标后的字符。
quoted−insert(C−q,C−v)
将输入的下一字符保持原样添加到行中。例如，可以用它来插入类似C−q的字符。
tab−insert(C−vTAB)
插入一个跳格符号。
self−insert(a,b,A,1,!,...)
插入键入的字符。
transpose−chars(C−t)
将point之前的字符向前移动，越过point处的字符，同时也改变point的位置。如果point在行尾，将调换point之前的两个字符。负数参数没有作用。
transpose−words(M−t)
将point之前的词向前移动，越过point处的词，同时也改变point的位置。如果point在行尾，将调换行中的最后两个词。
upcase−word(M−u)
将当前(或下一个)词变成全大写。有负值的参数时，将前一个词变为大写，但是不移动point。
downcase−word(M−l)
将当前(或下一个)词变成全小写。有负值的参数时，将前一个词变为小写，但是不移动point。
capitalize−word(M−c)
将当前(或下一个)词变为首字大写。有负值的参数时，将前一个词变为首字大写，但是不移动point。
overwrite−mode
控制插入/改写模式。给出一个正整数参数时，切换为改写模式。给出一个非正数参数时，切换为插入模式。这个命令只影响emacs模式；vi模式的改写与此不同。每个对readline()的调用都以插入模式开始。在改写模式下，关联到self−insert的字符替换point处的字符，而不是将它推到右边。关联到backward−delete−char的字符以空格替换point前的字符。默认情况下，这个命令没有关联。
KillingandYanking剪切和粘贴
kill−line(C−k)
剪切从point到行尾的文本。
backward−kill−line(C−xRubout)
反向剪切到行首。
unix−line−discard(C−u)
反向剪切到行首。与backward−kill−line没有什么区别。剪切的文本被保存于kill−ring中。
kill−whole−line
剪切当前行中所有字符，不管point在什么位置。
kill−word(M−d)
剪切从point到当前词尾，或者如果point在词之间，那么剪切到下一词尾。
backward−kill−word(M−Rubout)
剪切point之后的词。词的边界与backward−word使用的相同。
unix−word−rubout(C−w)
剪切point之后的词，使用空白作为词的边界。剪切的文本被保存于kill−ring中。
delete−horizontal−space(M−\)
删除point两边的所有空格和跳格。
kill−region
剪切当前region的文本。
copy−region−as−kill
将region的文本复制到剪切缓冲区中。
copy−backward−word
将point前面的词复制到剪切缓冲区中。词的边界与backward−word使用的相同。
copy−forward−word
将point之后的词复制到剪切缓冲区中。词的边界与backward−word使用的相同。
yank(C−y)
将kill−ring顶部的内容粘贴到point处的缓冲区中
yank−pop(M−y)
轮转kill−ring，粘贴新的顶部内容。只能在yank或yank−pop之后使用。
NumericArguments数值参数
digit−argument(M−0,M−1,...,M−−)
将这个数字加入已有的(alreadyaccumulating)参数中，或者开始新的参数。M−−开始一个否定的参数。
universal−argument
这是指定参数的另一种方法。如果这个命令后面跟着一个或多个数字，可能还包含前导的负号，这些数字定义了参数。如果命令之后跟随着数字，再次执行universal−argument将结束数字参数，但是其他情况下被忽略。有一种特殊情况，如果命令之后紧接着一个并非数字或负号的字符，下一命令的参数计数将乘以4。参数计数初始是1，因此第一次执行这个函数，使得参数计数为4，第二次执行使得参数计数为16，以此类推。
Completing补全
complete(TAB)
试着对point之前的文本进行补全。Bash依次试着将文本作为一个变量(如果文本以$开始)，一个用户名(如果文本以~开始)，主机名(如果文本以@开始)，或者命令(以及别名和函数)来补全。如果这些都没有匹配，将尝试文件名补全。
possible−completions(M−?)
列出point之前的文本可能的补全。
insert−completions(M−*)
插入possible−completions已产生的point之前的文本所有的补全。
menu−complete
与complete相似，但是使用可能的补全列表中的某个匹配替换要补全的词。重复执行menu−complete将遍历可能的补全列表，插入每个匹配。到达补全列表的结尾时，鸣终端响铃(按照bell−style的设置来做)并恢复初始的文本。参数n将在匹配列表中向前移动n步；负数参数可以用于在列表中向后移动。这个命令应当与TAB键关联，但是默认情况下是没有关联的。
delete−char−or−list
删除光标下的字符，如果不是在行首或行尾(类似delete−char)。如果在行尾，行为与possible−completions一致。这个命令默认没有关联。
complete−filename(M−/)
尝试对point之前的文本进行文件名补全。
possible−filename−completions(C−x/)
列出point之前的文本可能的补全，将它视为文件名。
complete−username(M−~)
尝试对point之前的文本进行补全，将它视为用户名。
possible−username−completions(C−x~)
列出point之前的文本可能的补全，将它视为用户名。
complete−variable(M−$)
尝试对point之前的文本进行补全，将它视为shell变量。
possible−variable−completions(C−x$)
列出point之前的文本可能的补全，将它视为shell变量。
complete−hostname(M−@)
尝试对point之前的文本进行补全，将它视为主机名。
possible−hostname−completions(C−x@)
列出point之前的文本可能的补全，将它视为主机名。
complete−command(M−!)
尝试对point之前的文本进行补全，将它视为命令名。命令补全尝试着将此文本依次与别名，保留字，shell函数，shell内建命令，最后是可执行文件名进行匹配。
possible−command−completions(C−x!)
列出point之前的文本可能的补全，将它视为命令名。
dynamic−complete−history(M−TAB)
尝试对point之前的文本进行补全，将此文本与历史列表中的行相比较来查找可能的补全匹配。
complete−into−braces(M−{)
进行文件名补全，将可能的补全列表放在花括号中插入，使得列表可以被shell使用(参见上面的BraceExpansion花括号扩展)。
KeyboardMacros宏
start−kbd−macro(C−x()
开始保存输入字符为当前键盘宏。
end−kbd−macro(C−x))
停止保存输入字符为当前键盘宏，保存宏定义。
call−last−kbd−macro(C−xe)
重新执行上次定义的键盘宏，即显示出宏中的字符，好像它们是从键盘输入的一样。
Miscellaneous
re−read−init−file(C−xC−r)
读入inputrc文件的内容，合并其中的按键关联和变量赋值。
abort(C−g)
取消当前编辑命令，鸣终端响铃(按照bell−style的设置来做)。
do−uppercase−version(M−a,M−b,M−x,...)
如果有Meta前缀的字符x是小写的，那么与命令相关连的是对应的大写字符。
prefix−meta(ESC)
将输入的下一个字符加上Meta前缀。ESCf等价于Meta−f.
undo(C−_,C−xC−u)
增量的撤销，分别记住每一行。
revert−line(M−r)
撤销这一行的所有修改。这与执行命令undo足够多次的效果相同，将这一行恢复到初始状态。
tilde−expand(M−&)
对当前词进行波浪线扩展。
set−mark(C−@,M−<space>)
在point处设置mark。如果给出了数值的参数，标记被设置到那个位置。
exchange−point−and−mark(C−xC−x)
交换point和mark。当前光标位置被设置为保存的位置，旧光标位置被保存为mark。
character−search(C−])
读入一个字符，point移动到这个字符下一次出现的地方。负数将搜索上一个出现。
character−search−backward(M−C−])
读入一个字符，point移动到这个字符上一次出现的地方。负数将搜索下面的出现。
insert−comment(M−#)
没有数值的参数时，readline变量comment−begin的值将被插入到当前行首。如果给出一个数值的参数，命令的行为类似于一个开关：如果行首字符不匹配comment−begin的值，将插入这个值，否则匹配comment−begin的字符将被从行首删除。在两种情况下，这一行都被接受，好像输入了新行符一样。comment−begin的默认值使得这个命令将当前行变成一条shell注释。如果数值参数使得注释字符被删除，这一行将被shell执行。
glob−complete−word(M−g)
point之前的词被当作路径扩展的一个模式，尾部暗含了一个星号。这个模式被用来为可能的补全产生匹配的文件名列表。
glob−expand−word(C−x*)
point之前的词被当作路径扩展的一个模式，匹配的文件名的列表被插入，替换这个词。如果给出一个数值参数，在路径扩展之前将添加一个星号。
glob−list−expansions(C−xg)
显示glob−expand−word可能产生的扩展的列表，重绘当前行。如果给出一个数值参数，在路径扩展之前将添加一个星号。
dump−functions
向readline输出流打印所有的函数和它们的按键关联。如果给出一个数值参数，输出将被格式化，可以用作inputrc文件一部分。
dump−variables
向readline输出流打印所有可设置的readline函数。如果给出一个数值参数，输出将被格式化，可以用作inputrc文件一部分。
dump−macros
向readline输出流打印所有关联到宏的readline按键序列以及它们输出的字符串。如果给出一个数值参数，输出将被格式化，可以用作inputrc文件一部分。
display−shell−version(C−xC−v)
显示当前bash实例的版本信息。
ProgrammableCompletion可编程补全
当试图对一个命令的参数进行词的补全时，如果已经使用内建命令complete定义了这个命令的补全规则(compspec)，将启动可编程补全功能(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节)。
首先，命令名被确认。如果针对这个命令有补全规则的定义，那么将使用规则来产生可能的词的补全的列表。如果命令词是一个路径全名，将首先搜索针对这个路径全名的规则。如果针对这个路径全名没有找到规则，将尝试查找针对最后一个斜杠后面的部分的规则。
一旦找到了一个规则，它将用作产生匹配的词。如果没有找到，将进行上面Completing中描述的bash默认的补全。
首先，将执行规则指定的动作。只有以被补全的词开始的匹配词才会被返回。当在文件或目录名补全中使用−f或−d选项时，shell变量FIGNORE将用于对匹配进行过滤。
接下来，将产生所有由−G选项给出的文件名扩展模式指定的补全。模式产生的词不必匹配要补全的词。shell变量GLOBIGNORE不会用于过滤匹配结果，但是变量FIGNORE会被使用。
接下来，将考虑−W选项的参数指定的字符串。这个字符串首先被划分，用特殊变量IFS中的字符作为分隔符。shell引用被当作一个词。接下来，每个词被扩展，使用上面EXPANSION中描述的braceexpansion,tildeexpansion,parameter和variableexpansion,commandsubstitution,arithmeticexpansion,以及pathnameexpansion规则处理。对于结果，再使用上面WordSplitting中描述的规则划分成词。扩展的结果与要补全的词进行前部一致的比较，匹配的词成为可能的补全。
在这些匹配被产生后，任何由−F和−C选项指定的shell函数和命令将被执行。当命令或函数被执行时，变量COMP_LINE和COMP_POINT被赋值，使用上面ShellVariables中的规则。如果要执行shell函数，还将设置变量COMP_WORDS和COMP_CWORD当函数或命令被执行时，第一个参数是等待参数被补全的命令的名称，第二个参数是要补全的词，第三个参数是当前命令行中，要补全的词前面的词。对要补全的词产生的补全不会进行任何过滤；函数或命令在产生匹配时有完全的自由。
任何−F指定的函数将被首先执行。函数可以使用任何shell功能，包含内建命令compgen，来产生匹配。它必须将可能的补全放到数组变量COMPREPLY中。
接下来，任何−C选项指定的命令将被执行，其执行环境与命令替换的环境相同。它应当向标准输出打印一个补全的列表，每行一个。反斜杠可以用来转义一个新行符，如果需要的话。
所有可能的补全都产生之后，将对列表进行−X选项指定的任何过滤。过滤器是一个模式，和路径名扩展中的一样；模式中的&替换为要补全的词。字面上的&可以用反斜杠转义；反斜杠在进行匹配时被删除。任何匹配这个模式的补全将从列表中删除。前导的!将使模式含义相反；这种情况下，任何不匹配这个模式的补全将被删除。
最后，B−P和−S指定的任何前缀和后缀被添加到补全列表的每个成员后面，结果返回给readline补全代码，作为可能的补全列表。
如果先前执行的动作没有产生任何匹配，并且在定义compspec规则时，为complete命令提供了−odirname选项，将尝试目录名补全。
默认情况下，如果找到了一个规则，它产生的任何东西都被返回给补全代码，作为可能的补全的全集。不再尝试默认的bash补全，readline默认的文件名补全也会禁止。如果定义规则时，为complete命令提供了−odefault选项，在规则没有产生匹配时将进行readline默认的补全处理。
当一个规则指出期望目录名补全时，可编程补全函数强制readline在补全的名称后面添加一个斜杠，如果它是一个到目录的符号连接。然后还要经过readline变量mark−directories的值处理，不管readline变量mark−symlinked−directories的值是什么。
历史(HISTORY)

当启用内建命令set的−ohistory选项时，shell允许访问commandhistory，以前输入的命令的列表。HISTSIZE的值用作命令列表中保存的命令数量。过去HISTSIZE个(默认为500)命令将被保存。shell将每条命令在进行参数和变量扩展之前保存到历史列表中(参见上面的EXPANSION段落)，但是是在历史扩展进行之后，并且要经过shell变量HISTIGNORE和HISTCONTROL处理。
在启动时，历史根据以变量HISTFILE的值为名的文件(默认是~/.bash_history)进行初始化。如果需要的话，以HISTFILE为名的文件将被截断，来包含不超过变量HISTFILESIZE的值指定的行数。当交互shell退出时，最后$HISTSIZE行被从历史列表中复制到$HISTFILE文件中。如果启用了shell选项histappend(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节中对内建命令shopt的描述)，这些行被追加到历史文件中，否则历史文件被覆盖。如果HISTFILE被取消定义，或者如果历史文件不可写，历史将不会保存。保存历史之后，历史文件被截断，以包含不超过HISTFILESIZE行。如果HISTFILESIZE被取消定义，不会进行截断操作。
内建命令fc(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节)可以用来列出或修改并重新执行历史列表中的一部分。内建命令history可以用来显示或修改历史列表，操作历史文件。当使用命令行编辑时，每种编辑模式都有搜索命令，提供对历史列表的访问。
shell允许控制哪些命令被保存到历史列表中。可以设置HISTCONTROL和HISTIGNORE变量，来使得shell只保存输入命令的一个子集。shell选项cmdhist如果被启用，将使得shell将多行的命令的每一行保存到同一个历史条目中，在需要的地方添加分号来保证语义的正确性。shell选项lithist使得shell保存命令时，保留嵌入的新行而不是用分号代替。参见下面shell内建命令(SHELLBUILTINCOMMANDS)中，内建命令shopt的描述，有关设置和取消shell选项的信息。
历史扩展("HISTORYEXPANSION")

shell支持历史扩展机制，类似于csh中历史扩展。这一节描述了可用的语法特征。在交互的shell中这一机制被默认启用，可以使用内建命令set的−H选项来禁用它(参见下面的shell内建命令(SHELLBUILTINCOMMANDS)章节)。非交互的shell默认不进行历史扩展。
历史扩展将历史列表中的词引入输入流中，使得可以方便地重复已执行命令，在当前输入行中为前一个命令插入新的参数，或者快速修正前一个命令中的错误。
历史扩展在读入一整行后，在shell将它拆分成词之前立即进行。它由两部分组成。首先是判断替换中使用历史列表中哪一行。其次是选择那一行中要包含到当前行中的部分。从历史中选择的行称为event，从那一行中选择的部分是words。可以用多种多样的modifiers来操纵所选的词。在读入输入时，行被按照同样方式分解成词，因此多个以metacharacter分隔的词，如果被引号包含，就被当成一个词。历史扩展由历史扩展字符引入，默认是!。只有反斜杠(\)和单引号可以引用历史扩展字符。
内建命令shopt可以设定多个选项值，来调整历史扩展的行为。如果shell选项histverify被启用(参见内建命令shopt的描述)，并且正在使用readline，历史替换不会被立即传给shell解释器。与此相对，扩展后的行被重新载入readline编辑缓冲区，进行进一步的修改。如果正在使用readline，并且启用了shell选项histreedit，失败的历史替换将被重新载入到readline编辑缓冲区，进行改正。内建命令history的−p选项可以用来在执行之前查看历史扩展将如何进行。内建命令history的−s选项可以用来在历史列表末尾添加命令，而不真正执行它们，从而在接下来的调用中可以使用它们。
shell允许控制历史扩展机制使用的多种字符(参见上面的ShellVariables中histchars的描述)。
EventDesignators
事件指示器(eventdesignator)是一个对历史列表中某个命令行条目的引用。
!
开始一个命令替换，除非后面跟随的是blank,newline,=或是(.
!n
引用命令行n.
!−n
引用当前命令行减去n.
!!
引用上一条命令。这是‘!−1’的同义词。
!string
引用最近的以string开始的命令。
!?string[?]
引用最近的包含string的命令。尾部的?可以被忽略，如果string之后紧接着一个新行符。
^string1^string2^
快速替换。重复上一条命令，将string1替换为string2.与‘‘!!:s/string1/string2/’’等价(参见下面的修饰符(Modifiers))。
!#
到此为止输入的整个命令行。
WordDesignators
词指示器(worddesignator)用于从event中选择期望的词。:分隔event规则与word指示器。它可以忽略，如果词指示器以^,$,*,−,或%开始。词被从行首开始编号，第一个词被表示为0。插入当前行中的词以单个空格分隔。
0(zero)
第0个词。对shell来将，这是命令名。
n
第n个词。
^
第一个参数。也就是，第1个词。
$
最后的参数。
%
最近一次搜索‘?string?’匹配的词。
x−y
一组词；‘−y’是‘0−y’的简写。
*
所有词，除了第0个。这是‘1−$’的同义词。如果event中只有一个词，使用*也不是错误；这种情况下将返回空字符串。
x*
x−$的简写。
x−
−$的简写，就像x*一样，但是忽略最后一个词。
如果给出了一个word指示器，没有给出event规则，前一个命令将用作event。
修饰符(Modifiers)
可选的word指示器之后，可以出现一个或多个下述modifiers的序列，每一个都前缀有‘:’。
h
删除文件名组成的尾部，只保留头部。
t
删除文件名组成中前面的成分，保留尾部。
r
删除.xxx形式中尾部的后缀成分，保留基本名称部分。
e
删除所有内容，保留尾部的后缀。
p
打印新的命令，但是不执行它。
q
引用替换所得的词，使它不再进行替换。
x
引用替换所得的词，类似与q,但是会根据blanks，空白和新行符分解为词。
s/old/new/
将事件行中出现的第一个old替换为new。任何分隔符都可以用来代替/，最后一个分隔符是可选的，如果它是事件行的最后一个字符。old和new中的分隔符可以用一个反斜杠来引用。如果&出现在new中，它将替换为old。可以用单个反斜杠来引用&。如果old为空，它将设置为最后替换的old，或者，如果前面没有发生过历史替换，就是!?string[?]搜索中的最后一个string。
&
重复上一次替换。
g
使得改变被整个事件行所接受。用于与‘:s’或‘:&’结合(例如，‘:gs/old/new/’)。如果与‘:s’结合使用，任何分隔符都可以用来代替/，最后一个分隔符是可选的，如果它是事件行的最后一个字符。
shell内建命令(SHELLBUILTINCOMMANDS)

除非另外说明，这一章介绍的内建命令如果接受−引导的选项，那么它也接受−−作为参数，来指示选项的结束
:[arguments]
没有效果；这个命令除了扩展arguments并且作任何指定的重定向之外，不做任何事。退出时返回0。
.filename[arguments]
sourcefilename[arguments]
读取并在当前shell环境中执行filename中的命令，返回filename中最后一个命令的返回状态。如果filename中不包含斜杠(slash)，系统将在PATH中查找包含filename的目录。在PATH中搜索的文件不必是可执行的。如果bash不是运行于posixmode，当PATH中找不到文件时会在当前目录搜索。如果shopt内建命令的sourcepath选项被关闭，PATH将不会被搜索。如果有任何arguments，它们成为filename的位置参数(positionalparameters)，否则位置参数不发生变化。返回状态是脚本中最后一个命令退出时的状态。没有执行命令则返回0，没有找到或不能读取filename时返回false。
alias[−p][name[=value]...]
Alias不带参数或者带−p参数运行时将在标准输出以这样的格式aliasname=value给出别名列表。如果有参数，将创建提供了value的name的别名。value中尾部的空格使得别名被扩展时，下一个词做别名替换。对于参数列表中的每一个name，如果value没有给出，这个别名的名称和值会被打印出来。Alias返回true除非name没有定义为别名。
bg[jobspec]
使挂起的程序jobspec在后台继续执行，就好像它是用&启动的一样。如果没有指定jobspec，shell意义上的currentjob当前作业将被使用。bgjobspec返回0，除非当前禁止了作业控制，或者在允许作业控制，但是没有找到jobspec，或者它不是在作业控制下启动的时候。
bind[−mkeymap][−lpsvPSV]
bind[−mkeymap][−qfunction][−ufunction][−rkeyseq]
bind[−mkeymap]−ffilename
bind[−mkeymap]−xkeyseq:shell−command
bind[−mkeymap]keyseq:function−name
bindreadline−command
显示当前readline键和功能的，将一个按键序列和一个readline功能或宏进行关联，或者设置一个readline变量。每一个在非选项的参数都是一个命令，好像它是在.inputrc中出现的一样。但是每个关联或者命令必须作为单独的参数传递；也就是这样’"\C−x\C−r":re−read−init−file’。如果有参数，它们有如下的意义：
−mkeymap
使用keymap作为随后的关联的keymap。可选的keymap名称是emacs,emacs−standard,emacs−meta,emacs−ctlx,vi,vi−move,vi−command，还有vi−insert。vi和vi−command等价;emacs和emacs−standard等价。
−l
列出所有的readline功能。
−p
以程序可读的方式显示readline功能名称和关联
−P
列出当前readline功能名称和关联。
−v
以程序可读的方式显示readline变量名称和值
−V
列出当前readline变量和值。
−s
以程序可读的方式显示readline键序列和对应的宏
−S
显示readline宏对应的键序列和他们输出的字符串
−ffilename
从filename中读取键序列
−qfunction
查询那些键将执行function。
−ufunction
取消所有关联到function的键。
−rkeyseq
取消当前任何keyseq的关联。
−xkeyseq:shell−command
使shell−command在keyseq按下时被执行。
返回值是0，除非给出了一个不能识别的选项或是产生了一个错误。
break[n]
从一个for,while,until,或者select循环退出。如果指定了n，就跳出n层循环。n必须≥1。如果n比当前循环层数还要大，将跳出所有循环。返回值是0，除非执行break的时候shell不是在执行一个循环。
builtinshell−builtin[arguments]
执行指定的shell内建命令，传递arguments，返回命令的返回值。这在定义了一个和shell内建命令同名的函数时很有用，在那个函数中使用它来执行相应的功能。cd命令常以这种方式重新定义。返回状态是false，如果指定的shell−builtin并不是一个shell内建命令。
cd[−L|-P][dir]
改变当前路径到dir。这个变量的默认值是HOME目录。环境变量CDPATH定义了包含dir的搜索路径。在CDPATH中可选的路径名以冒号(:)分隔。CDPATH中的空路径名与当前路径相同，就是‘‘.’’.如果目录名以斜杠(/,slash)起始，那么CDPATH不会被使用。−P选项是说使用物理路径结构而不是跟随符号链接，(参见set命令中的−P选项);−L选项强制跟随符号链接。另外，选项−与$OLDPWD是相同的。返回值是true，如果成功地改变了目录；否则是false。
command[−pVv]command[arg...]
运行command，使用args作为参数，禁止通常的查找shell函数的过程。只有内建命令或者PATH中包含的命令可以执行。如果给出−p参数，command的查找是以PATH的默认值进行的。这样可以保证找到所有的标准工具。如果给出−V或者−v选项，关于command的说明将被打印出来。−v选项使得表述这个命令的词，或者要执行command需要执行的文件显示出来；−V选项给出更详细的描述。如果给出−V或者−v选项，退出状态在找到了command的情况下0，没找到就是1。如果没有提供选项，并且产生了错误或者command没有找到，退出状态就是127。否则，command内建命令的退出状态是command的退出状态。
compgen[option][word]
根据option为word产生可能的补全。option是内建命令complete接受的任何选项，除了−p和−r，将匹配结果写到标准输出。当使用−F或−C选项时，可编程补全功能所设置的多数shell变量如果存在，其值将不再有用。
产生的匹配与可编程补全代码根据补全规则加上相同的标志直接产生的结果相同。如果指定了word，只有匹配word的补全结果将被显示出来。
返回值为真，除非提供了非法的选项，或者没有产生匹配。
complete[−abcdefgjksuv][−ocomp-option][−Aaction][−Gglobpat][−W
wordlist][−Pprefix][−Ssuffix]
[−Xfilterpat][−Ffunction][−Ccommand]name[name...]
complete−pr[name...]
指定每个name的参数应当如何被补全。如果给出了−p选项，或者没有选项给出，现有的补全规则将被显示出来，以一种可以重用为输入的格式显示。−r选项将一个针对每个name的补全规则删除。或者，如果没有给出name，将删除所有补全规则。
尝试词的补全时，应用这些补全规则的过程在上面ProgrammableCompletion(可编程补全)中详述。
其他选项，如果给出的话，具有下列意义。−G,−W,和−X选项的参数(如果需要的话，还包括−P和−S选项)应当被引用，避免在执行内建命令complete之前被扩展。
−ocomp-option
comp-option控制着compspec除了简单地产生补全之外的多种行为。comp-option可以是如下之一：
default
使用readline的默认文件名补全，如果compspec没有得到匹配。
dirnames
进行目录名补全，如果compspec没有得到匹配。
filenames
告诉readline，compspec产生了文件名，使它可以进行任何文件名专用的处理(例如，给目录名加上斜杠或消除尾部空白)。主要用于shell函数。
nospace
告诉readline不要向补全的词在行的最后添加一个空格(这是默认行为)。
−Aaction
action可以是下列之一，来产生一系列可能的补全结果：
alias
起别名。也可以用−a指定。
arrayvar
数组变量名。
binding
Readline按键关联。
builtin
shell内建命令的名称。也可以用−b指定。
command
命令名。也可以用−c指定。
directory
目录名。也可以用−d指定。
disabled
被禁用的内建命令名称。
enabled
启用的内建命令名称。
export
被导出的shell变量名称。也可以用−e指定。
file
文件名。也可以用−f指定。
function
shell函数的名称。
group
组名。也可以用−g指定。
helptopic
内建命令help接受的帮助主题。
hostname
主机名，从环境变量HOSTFILE指定的文件中得到。
job
作业名，如果作业控制被激活的话。也可以用−j指定。
keyword
shell保留字。也可以用−k指定。
running
正在运行的作业名，如果作业控制被激活的话。
service
服务名。也可以用−s指定。
setopt
内建命令set的−o选项的有效参数。
shopt
内建命令shopt接受的shell选项名。
signal
信号名。
stopped
停止的作业名，如果作业控制被激活的话。
user
用户名。也可以用−u指定。
variable
shell变量的名称。也可以用−v指定。
−Gglobpat
文件名扩展模式globpat被扩展，产生可能的补全。
−Wwordlist
wordlist被使用IFS特殊变量中的字符作为定界符来拆分，每个结果的词被扩展。可能的补全是结果列表中匹配要补全的词的那一些。
−Ccommand
command将在一个子shell环境中执行，它的结果用作可能的补全。
−Ffunction
shell函数function将在当前shell环境中执行。当它结束时，可能的补全可以从数组元素COMPREPLY中得到。
−Xfilterpat
filterpat是一个模式，用于文件名扩展。所有前面的选项和参数产生的可能的补全都要经过这一步处理，每一个匹配filterpat的补全都被从列表中删除。为filterpat加上前导!使模式意义相反；这种情况下，所有不匹配filterpat的模式被删除。
−Pprefix
在所有其他选项都处理过之后，prefix被加到每个可能的补全前面。
−Ssuffix
在所有其他选项都处理过之后，suffix被加到每个可能的补全后面。
返回值为真，除非给出了非法的选项，给出除−p和−r之外的某个选项时没有给出name参数，试图删除一条name的补全规则但是规则不存在，或者添加补全规则时出错。
continue[n]
复位到外层for,while,until,或select循环的下一次开始。如果指定了n，复位到向外第n层循环的开始。n必须≥1。如果n比外部循环的层数要多，将复位到最外层的循环(‘‘top-level’’loop，顶层循环)。返回值是0，除非执行continue时，shell不是在循环之中。
declare[−afFirtx][−p][name[=value]]
typeset[−afFirtx][−p][name[=value]]
声明变量且/或设置它们的属性。如果没有给出name则显示变量的值。选项−p将显示每个名称name的属性和值。当使用−p时，其他选项被忽略。选项−F禁止显示函数定义；只有函数名和属性会被显示。−F选项暗含−f.下列选项可用来限制只输出具有指定属性的变量，或者为变量设置属性：
−a
每个name都是数组变量(参见上面的Arrays段落)。
−f
只使用函数名。
−i
变量被当作一个整数；当变量被赋值时将进行算术运算(参见算术求值(ARITHMETICEVALUATION)章节)。
−r
使得name只读。这些名称不能再被后续的赋值语句赋值或取消定义。
−t
设置每个name的trace(跟踪)属性。被跟踪的函数继承了调用者shell的DEBUG陷阱。trace属性对变量没有特殊意义。
−x
标记name为可以通过环境导出给后续命令。
使用‘+’代替‘−’将关闭属性，特殊情况是+a不能用于销毁一个数组变量。当用于函数中时，它使得每个name成为局部的，就像使用了local命令。返回值是0，除非遇到了非法的选项，试图使用‘‘−ffoo=bar’’定义函数，试图向只读变量赋值，试图向数组变量赋值但没有使用复合的赋值语法(参见上面的Arrays段落)，name之一不是有效的shell变量名，试图将数组变量的数组状态关闭，或者是试图使用−f显示一个不存在的函数。
dirs[−clpv][+n][−n]
没有选项时显示当前保存的目录。默认输出为一行，目录名用空格分开。可以使用pushd命令将目录添加到列表，popd命令将列表中的条目删除。
+n
显示dirs在不带选项执行时显示的列表的第n个条目，从0开始自左算起。
−n
显示dirs在不带选项执行时显示的列表的第n个条目，从0开始自右算起。
−c
删除所有条目，清空目录栈。
−l
产生长列表；默认列表格式使用波浪线来表示个人目录。
−p
输出目录栈，一行一个。
−v
输出目录栈，一行一个，每个条目前面加上它在栈中的位置索引。
返回值是0，除非给出了非法的参数，或者n索引超出了目录栈的范围。
disown[−ar][−h][jobspec...]
没有选项时，每个jobspec被从正在运行的作业表中删除。如果给出了−选项，每个jobspec并不从表中删除，而是被标记，使得在shell接到SIGHUP信号时，不会向作业发出SIGHUP信号。如果没有给出jobspec，也没有给出−a或者−r选项，将使用当前作业(currentjob)。如果没有给出jobspec，选项−a意味着删除或标记所有作业；选项−r不带jobspec参数时限制操作只对正在运行的作业进行。返回值是0，除非jobspec不指定有效的作业。
echo[−neE][arg...]
输出arg，以空格分开，最后加一个新行符。返回值总是0。如果指定了−n，将不在尾部添加新行符。如果给出了−e选项，将允许解释下列反斜杠转义的字符。−E选项禁止这些转义字符的解释，即使在默认解释它们的系统中也是如此。shell选项xpg_echo可以用来在运行时判断echo是否默认展开这些转义字符。echo不将−−作为选项的结束。echo解释下列转义序列：
\a
alert(bell)响铃
\b
backspace回退
\c
suppresstrailingnewline删除尾部新行符
\e
anescapecharacter字符Esc
\f
formfeed进纸
\n
newline新行符
\r
carriagereturn回车
\t
horizontaltab水平跳格
\v
verticaltab竖直跳格
\\
backslash反斜杠
\0nnn
一个八比特字符，它的值是八进制值nnn(零到三个八进制数字)。
\nnn
一个八比特字符，它的值是八进制值nnn(一到三个八进制数字)。
\xHH
一个八比特字符，它的值是十六进制值HH(一到两个十六进制数字)。
enable[−adnps][−ffilename][name...]
允许或禁止shell内建命令。禁止一个内建命令使得磁盘上的与内建命令同名的文件得以运行，不必使用它的全路径，即使shell一般在搜索磁盘上的命令之前搜索内建命令。如果使用了−n选项，每个name都被禁止；否则，name被允许。例如，要使用PATH中搜索到的test命令而不是shell内建的那一个，可以运行‘‘enable-ntest’’.选项−f意味着从共享库filename中加载新的内建命令name，如果系统支持动态加载的话。选项−d将删除曾经用−f加载的内建命令。如果没有给出name参数，或者给出了−p选项，将显示shell内建命令的列表。如果没有其他选项参数，这个列表只包含所有被允许的shell内建命令；如果给出了−n，将只显示被禁止的内建命令；如果给出了−a，显示的列表中包含所有内建命令，还有命令是否被允许的指示；如果给出了−s，输出被限制为POSIXspecial内建命令。返回值是0，除非name不是shell内建命令，或者从共享库中加载新的内建命令时出错。
eval[arg...]
arg被读取并连结为单一的命令。这个命令然后被shell读取并执行，它的退出状态被作为eval的值返回。如果没有args，或仅仅包含空参数，eval返回0。
exec[−cl][−aname][command[arguments]]
如果指定了command，它将替换shell。不会产生新的进程。arguments成为command的参数。如果给出了−l选项，shell将在传递给command的第0个参数前面加上一个连字符(dash,‘-’)。这样做和login(1)相同。选项−c使得命令command在一个空环境中执行。如果给出了−a，shell会将name作为第0个参数传递给要执行的命令。如果由于某种原因asthezerothargumenttotheexecutedcommand.Ifcommand不能被执行，非交互的shell将退出，除非shell选项execfail被设置为允许，这种情况下它返回失败。如果命令不能执行，交互的shell返回失败。如果没有指定command任何重定向对当前shell发生作用，返回值是0。如果发生重定向错误，返回状态是1。
exit[n]
使得shell以状态值n退出。如果忽略了n，退出状态是最后执行的命令的退出状态。在shell终止前，对EXIT的陷阱将被执行。
export[−fn][name[=word]]...
export−p
给出的名称names被标记为自动地导出到后续执行的命令的环境中。如果给出了−f选项，名称names指的是函数。如果没有给出names，或者如果给出了−p选项，将打印在这个shell中被导出的所有名字的列表。选项−n使得以此为名的变量的导出属性被删除。export返回0，除非遇到了非法的选项，name之一不是有效的shell变量名，或者给出了−f选项，而name不是一个函数。
fc[−eename][−nlr][first][last]
fc−s[pat=rep][cmd]
命令修复。第一种形式中，历史列表中从first到last范围内的命令都被选取。First和last可以指定为字符串(可以定位最后一个以此字符串开始的命令)或者数字(历史列表中的索引，负数被当作相对当前命令号的偏移)。如果没有指定last，它在列举时被设为当前命令(因此‘‘fc−l−10’’将输出最后10条命令)，其他情况下被设为first。如果没有指定first，它在编辑时被设为前一个命令，列举是设为−16。
选项−n使得列举时不显示命令号码。选项−r将命令顺序进行掉换。如果给出了−l选项，命令将列举在标准输出上。否则，将启动ename给出的编辑器，编辑包含这些命令的文件。如果没有给出ename，将使用变量FCEDIT的值，如果FCEDIT没有定义就使用EDITOR的值。如果仍然没有定义，将使用vi。编辑结束后，被编辑的命令将回显并执行。
第二种形式中，command在每个pat的实例被rep替换后都被重新执行。使用这种特性时可以起一个有用的别名：‘‘r=fc-s’’,这样输入‘‘rcc’’将运行最后的以‘‘cc’’开头的命令，输入‘‘r’’将重新执行上一个命令。
如果使用第一种形式，返回值是0，除非遇到了非法的选项，或first或last指定的历史行数超出了范围。如果给出了−e选项，返回值是最后执行的命令的返回值，或着是失败，如果临时文件中的命令执行出错。如果使用第二种形式，返回状态是重新执行的命令，除非cmd没有指定一个有效的历史行，这种情况下fc返回失败。
fg[jobspec]
将jobspec恢复至前台，使它成为当前作业。如果jobspec不存在，将使用shell意义上的当前作业currentjob。返回值是被放到前台的命令的状态，或者是失败，如果在禁用作业控制时运行，或者在启用作业控制时运行，但jobspec没有指定有效的作业，或jobspec指定了没有使用作业控制的作业。
getoptsoptstringname[args]
getopts由shell程序用来处理位置参数。optstring包含要识别的选项字符；如果某个字符跟随着冒号，那么这个选项需要一个参数，需要用空白和它隔离开。冒号和问号字符不能用作选项字符。每次它执行时，getopts将下一个选项放在shell变量name中，如果name不存在就初始化它；下一个要处理的参数的索引放在变量OPTIND中。每次shell或shell脚本被执行的时候OPTIND被初始化为1。当某个选项需要参数时，getopts将那个参数放到变量OPTARG中。shell不会自动重置OPTIND；在相同的shell中，如果要使用新的参数集合而需要多次调用getopts时，必须手动重置它。
当遇到选项结束的时候，getopts以大于0的值退出。OPTIND被设置为第一个非选项的参数的索引，name被设置为?。
getopts通常解释位置参数，但是如果args中给出了更多参数，getopts将解释它们。
getopts能以两种方式报告错误。如果optstring的第一个字符是冒号，将使用silent安静的错误报告。通常的操作中，遇到非法选项或缺少选项的参数时将打印出诊断信息。如果变量OPTERR被设置为0，不会显示错误消息，即使optstring的第一个字符不是冒号。
如果发现了一个非法的选项，getopts向name中置入?，并且如果不是安静模式的话，打印错误消息并取消OPTARG的定义。如果getopts是安静模式，找到的选项字符将置入OPTARG，不会打印诊断消息。
如果没有找到需要的参数，并且getopts不是安静模式，将向name置入一个问号(?)，取消OPTARG的定义，打印出诊断消息。如果getopts是安静模式，那么将向name置入一个冒号(:)并且OPTARG将设置为找到的选项字符。
getopts返回真，如果找到了指定的/未被指定的选项。它返回假，如果遇到了选项结束或者发生了错误。
hash[−lr][−pfilename][−dt][name]
对于每个name,通过搜索$PATH中的目录，找到命令的全路径名并记录它。如果给出了−p选项，不会进行路径搜索，直接将filename作为命令的全路径名。选项−r使得shell忘记所有已记录的位置。选项−d使得shell忘记已记录的name的位置。如果给出了−t选项，每个name对应的全路径名被打印出来。如果给出多个name作为−t的参数，name将在已记录的全路径名之前被打印出来。选项−l使得输出以一种可以重用为输入的格式显示。如果没有给出参数，或者只给出了−l选项，已记录的命令的信息将被打印出来。返回真，除非name没有找到或给出了非法的选项。
help[−s][pattern]
显示关于内建命令的有用的信息。如果指定了pattern(模式)，help给出关于所有匹配pattern的命令的详细帮助；否则所有内建命令的帮助和shell控制结构将被打印出来。选项−s限制信息显示为简短的用法概要。返回0，除非没有匹配pattern的命令。
history[n]
history−c
history−doffset
history−anrw[filename]
history−parg[arg...]
history−sarg[arg...]
不带选项的话，显示带行号的命令历史列表。列出的行中含有*的已经被修改过。参数n使得只显示最后n行。如果给出了filename，它被用做历史文件名；没有的话，将使用HISTFILE的值作为历史文件名。选项如果给出，则具有下列意义：
−c
清空历史列表，删除所有条目。
−doffset
删除offset位置的历史条目。
−a
将‘‘新’’的历史条目(自当前bash会话开始输入的历史命令)追加到历史文件中。
−n
将尚未从历史文件中读取的历史条目读入当前历史列表。这些行是当前bash会话开始之后，才追加到历史文件中的行。
−r
读取历史文件的内容，使用它们作为当前历史。
−w
将当前历史列表写入历史文件，覆盖历史文件的原有内容。
−p
对后续的args进行历史替换，在标准输出上显示结果。不会将结果存入历史列表。每个args都必须被引用，来禁止普通的命令扩展。
−s
将args保存到历史列表中，作为单独的条目。历史列表中的最后一个命令在添加args之前被删除。
返回0，除非遇到了非法的选项，读/写历史文件发生错误，在−d的参数中给出了无效的offset，或者对−p的后续参数进行历史扩展失败。
jobs[−lnprs][jobspec...]
jobs−xcommand[args...]
第一种形式列出正在运行的作业。选项具有下列意义：
−l
普通信息之外，列出进程ID。
−p
只列出作业的进程组leader的进程ID。
−n
只显示从上次用户得知它们的状态之后，状态发生改变的作业的信息。
−r
限制只输出正在运行的作业。
−s
限制只输出停止的作业。
如果给出了jobspec输出被限制为仅此作业的信息。返回0，除非遇到了非法的选项或给出了非法的jobspec。
如果给出了−x选项，作业jobs将command或args中的任何jobspec替换为相应的进程组ID，执行command，传递参数args给它并返回它的退出状态。
kill[−ssigspec|−nsignum|−sigspec][pid|jobspec]...
kill−l[sigspec|exit_status]
向以pid或jobspec为名的进程发送名为sigspec或signum的信号。sigspec可以是一个信号名称，类似SIGKILL或信号编号；signum是一个信号编号。如果sigspec是一个信号名称，那么可以有，也可以没有SIG前缀。如果没有给出sigspec，那么假设是SIGTERM。参数−l将列出所有信号的名称。如果给出−l时还有任何参数，将列出参数对应的信号名称，返回状态0。−l的exit_status参数是一个数字，指定了一个信号编号或被信号终止的进程的退出状态值。kill返回真，如果至少成功发送了一个信号，或者返回假，如果发生了错误或遇到了非法的选项。
letarg[arg...]
每个arg都是要求值的算术表达式(参见算术求值(ARITHMETICEVALUATION)章节)。如果最后一个参数arg求值结果是0，let返回1；否则返回0。
local[option][name[=value]...]
对每个参数将创建一个名为name的局部变量并赋予值value。option可以是任何declare接受的值。当local用于函数内部时，它使得变量name作用域局限于函数和它的子进程。没有操作数时，local将局部变量的列表写到标准输出。不在函数内部使用local会导致出错。返回0，除非在函数之外使用了local，给出了非法的name，或者name是一个只读的变量。
logout
退出登录shell。
popd[−n][+n][−n]
从目录栈中删除条目。没有参数的话，从栈中删除顶层目录，执行cd切换到新的顶层目录。如果给出了参数，有下列的含义：
+n
删除dirs给出的列表中从左数第n个条目(从0算起)。例如：‘‘popd+0’’删除第一个目录，‘‘popd+1’’第二个。
−n
删除dirs给出的列表中从右数第n个条目(从0算起)。例如：‘‘popd-0’’删除最后一个目录，‘‘popd-1’’删除倒数第二个。
−n
阻止从栈中删除目录之后改变目录，这时只对栈进行操作。
如果命令popd成功，还要执行一个dirs，返回0。popd返回假，如果遇到了非法的选项，目录栈为空，指定了目录栈中不存在的条目，或者改变目录失败。
printfformat[arguments]
在format控制下将格式化的arguments写到标准输出。format是一个字符串，包含三种类型的对象：普通字符，被简单地复制到标准输出，转义字符，被转换并复制到标准输出，格式说明，每一个都使得相邻的下一个argument被打印出来。在标准的printf(1)格式之外，%b使得printf展开相应arguments中的反斜杠转义序列，%q使得printf将相应的argument以一种可以重用为shell输入的格式输出。
format在需要时被重用，以处理所有的arguments。如果format需要比所提供的更多的arguments，多出的格式说明视为已经提供了相应的0值或空字符串。成功的话返回值是0，失败则是非0值。
pushd[−n][dir]
pushd[−n][+n][−n]
将目录推入目录栈，或者轮换栈中的内容，使栈的顶部成为当前工作目录。没有参数时，交换顶部两个目录，返回0，除非目录栈为空。如果给出了参数，它们有如下含义：
+n
轮换栈中内容，使得dirs给出的列表中从左数第n个目录(从0数起)成为目录栈的顶部。
−n
轮换栈中内容，使得dirs给出的列表中从右数第n个目录(从0数起)成为目录栈的顶部。
−n
阻止向栈中添加目录之后改变目录，这时只对栈进行操作。
dir
添加dir到栈顶，使得它成为新的当前工作目录。
如果命令pushd成功，还要执行一个dirs。如果使用第一种形式，pushd返回0，除非cd切换到目录dir失败。使用第二中形式时，pushd返回0，除非目录栈为空，指定了目录栈中不存在的元素，或者切换到指定的新的当前目录失败。
pwd[−LP]
打印当前工作目录的绝对路径名。如果给出了−P选项，或者设置了内建命令set的−ophysical选项，打印出的路径名中不会包含符号链接。如果使用了−L选项，打印出的路径中可能包含符号链接。返回0，除非在读取当前目录名时出错或给出了非法的选项。
read[−ers][−ufd][−ttimeout][−aaname][−pprompt][−nnchars][−d
delim][name...]
从标准输入读入一行，或从−u选项的参数中给出的文件描述符fd中读取，第一个词被赋予第一个name,第二个词被赋予第二个name,以此类推，多余的词和其间的分隔符被赋予最后一个name.如果从输入流读入的词数比名称数少，剩余的名称被赋予空值。IFS中的字符被用来将行拆分成词。反斜杠字符(\)被用于删除读取的下一字符的特殊含义，以及续行。如果给出了选项，将包含下列含义：
−aaname
词被赋以数组变量aname的连续的下标，从0开始。在赋新值之前，aname被取消定义。其他name参数被忽略。
−ddelim
delim的第一个字符被用于结束输入行，而不是新行符。
−e
如果标准输入来自终端，将使用readline(参见上面的READLINE章节)来获得输入行。
−nnchars
read读入nchars个字符后返回，而不是等待一整行输入。
−pprompt
读取任何输入之前，在标准错误显示提示prompt，末尾没有新行符。提示只有在输入来自终端时才会显示。
−r
反斜杠不作为转义字符。反斜杠被认为行的一部分。特殊地，一对反斜杠-新行符不作为续行。
−s
安静模式。如果输入来自终端，字符将不会回显。
−ttimeout
使得read超时并返回失败，如果在timeout秒内没有读入完整的一行输入。如果read不是从终端或管道读取输入，那么这个选项无效。
−ufd
从文件描述符fd中读取输入。
如果没有给出names，读取的一行将赋予变量REPLY。返回值是0，除非遇到了EOF，readP超时，或给出了非法的文件描述符作为−u的参数。
readonly[−apf][name...]
给出的name将被标记为只读的；names的值不能被后来的赋值语句改变。如果给出了−f选项，names对应的函数也被标记。选项−a限制变量只能是数组类型。如果没有给出name参数，或者如果给出了−p选项，将打印所有只读的名称。选项−p使得输出以一种可以被重新用作输入的格式显示。返回值是0，除非遇到了非法的选项，names之一不是有效的shell变量名，或选项−f中给出的name不是一个函数。
return[n]
使得一个函数以指定值n退出。如果忽略了n，返回状态是函数体中执行的最后一个命令的退出状态。如果在函数外使用，但是是在一个以.(source)命令执行的脚本内，它使得shell中止执行脚本，返回n或脚本中执行的最后一个命令的退出状态。如果在函数外使用，并且不是在以.执行的脚本内，返回状态是假。
set[−−abefhkmnptuvxBCHP][−ooption][arg...]
不带选项时，shell变量的名称和值将以一种可以重用为输入的格式显示。输出根据当前语言环境进行排序。指定了选项的时候，它们设置或取消了shell的属性。处理完选项之后剩余的任何参数都被作为位置参数的值被赋值，分别赋予$1,$2,...$n.如果给出了选项，那么具有以下含义：
−a
自动将被修改或创建的变量和函数标志为导出至后续命令的环境中。
−b
后台作业结束时立即报告状态，而不是在下次显示主提示符前报告。只有在启用作业控制时才有效。
−e
立即退出，如果simplecommand(简单命令，参见上面的SHELLGRAMMAR语法)以非零值退出。shell不会退出，如果失败的命令是until或while循环的一部分，if语句的一部分，&&或⎪⎪序列的一部分，或者命令的返回值是由!翻转得到。针对ERR的陷阱，如果设置的话，将在shell退出前执行。
−f
禁止路径扩展。
−h
在查找并执行命令时，记住它们的位置。这是默认启用的。
−k
所有以赋值语句形式出现的参数都被加入到命令执行的环境中，不仅是命令名前面那些。
−m
监视模式。作业控制被启用。在支持这个选项的系统中，它在交互shell中是默认启用的(参见上面的JOBCONTROL作业控制)。后台进程在单独的进程组中运行，结束时将打印出包含它们退出状态的一行信息。
−n
读取命令，但不执行。这可以用在检查shell脚本中的语法错误。交互shell中它被忽略。
−ooption−name
option−name可以是如下之一：
allexport
与−a相同。
braceexpand
与−B相同。
emacs
使用emacs样式的命令行编辑界面。这个选项在交互shell中默认启用，除非shell以−−noediting选项启动。
errexit
与−e相同。
hashall
与−h相同。
histexpand
与−H相同。
history
允许记录命令历史，如上述HISTORY中的描述。这个选项在交互shell中默认启用。
ignoreeof
它的效果是好像已经执行了shell命令‘‘IGNOREEOF=10’’一样(参见上面的ShellVariables变量)。
keyword
与−k相同。
monitor
与−m相同。
noclobber
与−C相同。
noexec
与−n相同。
noglob
与−f相同。nolog当前被忽略。
notify
与−b相同。
nounset
与−u相同。
onecmd
与−t相同。
physical
与−P相同。
posix
如果默认操作与POSIX1003.2不同的话，改变bash的行为，来满足标准(posixmode)。
privileged
与−p相同。
verbose
与−v相同。
vi
使用vi样式的命令行编辑界面。
xtrace
与−x相同。
如果给出了不带option−name的−o选项，当前选项的值将被打印出来。如果给出了不带option−name的+o选项，将在标准输出显示一系列可以重建当前选项设定的set命令。
−p
打开privilegedmode(特权模式)。在这个模式中，不会处理$ENV和$BASH_ENV文件，shell函数不会从环境中继承，环境中如果有变量SHELLOPTS，也将被忽略。如果shell启动时的有效用户(组)ID与真实用户(组)ID不同，并且没有给出−p选项，将执行这些操作，有效用户ID将设置为真实用户ID。如果启动是给出了−p选项，有效用户ID不会被重置。将这个选项关闭使得有效用户和组ID被设置为真实用户和组ID。
−t
读取并执行一个命令之后退出。
−u
在进行参数扩展时，将未定义的变量作为错误。如果试图扩展未定义的变量，shell将输出一条错误消息;如果是非交互的shell，shell将以非零值退出。
−v
在读取输入的同时打印出来。
−x
扩展每个简单命令之后，显示PS4的值，接着显示命令和它扩展后的参数。
−B
shell执行花括号扩展(参见上面的BraceExpansion)。这是默认允许的。
−C
如果设置的话，bash使用重定向操作符>,>&,和<>时，不会覆盖已存在的文件。可以使用重定向操作符>|代替>来创建输出文件，从而绕过这个限制。
−H
允许Enable!样式的历史替换。在交互shell中这个选项是默认启用的。
−P
如果设置的话，shell在执行类似cd的，改变当前工作目录的命令时，不会跟随符号连接。它将使用物理的目录结构来代替。默认情况下，bash在执行改变当前目录的命令时跟随路径的逻辑链。
−−
如果这个选项没有参数，将取消位置参数的定义。否则，位置参数将设置为arg，即使它们以−开始。
−
通知信号的结束，使得所有剩余的arg被赋予位置参数。−x和−v选项被关闭。如果没有arg，位置参数将不会改变。
这个选项默认是关闭的，除非另外说明。使用+而不是−使得这些选项被关闭。选项都可以作为参数，在shell启动时指定。当前的选项集合可以从$−找到。返回值总是真，除非遇到了非法的选项。
shift[n]
从n+1...开始的选项被重命名为$1....从$#向下直到$#−n+1的选项被取消定义。n必须是非负整数，小于或等于$#。如果n是0，不会改变参数。如果没有给出n，就假定它是1。如果n比$#大，位置参数不会改变。返回值大于0，如果n比$#大或小于0；否则返回0。
shopt[−pqsu][−o][optname...]
对于控制可选的shell行为的变量，改变它们的值。没有选项或者有−p选项时，将显示所有可设置的选项列表，以及它们是否已经设置的指示。−p使得输出以一种可以被重用为输入的形式显示。其他选项有如下含义：
−s
允许(设置)每个optname。
−u
禁止(取消)每个optname。
−q
禁止通常的输出(安静模式)；返回状态指示了optname是否被设置。如果对−q给出了多个optname参数，如果所有optname都被允许，返回值就是0；否则返回非零值。
−o
限制optname的值为内建命令set的−o选项定义的值。
如果使用−s或−u时没有给出optname参数，显示将分别限于被设置或被取消的选项。除非另外说明，shopt选项默认被禁止(取消)。
返回值在列出选项时是0，如果所有optname都被允许的话，否则是非零值。当设置或取消选项时，返回值是0，除非optname是非法的shell选项。
shopt选项的列表是：
cdable_vars
如果设置的话，内建命令cd的参数如果不是目录，就假定是一个变量，它的值是要切换到的目录名。
cdspell
如果设置的话，cd命令中目录的细微拼写错误能够得以纠正。检查的错误包括字符错位，缺字符，重复输入同一字符。如果找到了正确的值，将打印正确的文件名，命令将继续。这个选项只能在交互shell中使用。
checkhash
如果设置的话，bash在执行命令前检测散列表中的命令是否存在。如果一个被散列的命令不再存在，将进行正常的路径搜索。
checkwinsize
如果设置的话，bash在每条命令执行后检测窗口大小，如果需要的话就更新LINES和COLUMNS的值。
cmdhist
如果设置的话，bash试着将一个多行命令的所有行放到同一个历史条目中。这样使得多行命令可以容易地重新修改。
dotglob
如果设置的话，bash会把以‘.’开始的文件名包含在路径名扩展的结果中。
execfail
如果设置的话，非交互的shell如果不能执行作为参数提供给内建命令exec的文件时将不会退出。交互的shell在exec失败时不会退出。
expand_aliases
如果设置的话，别名被扩展，就像上面ALIASES中讲到的一样。这个选项在交互shell中是默认启用的。
extglob
如果设置的话，将允许上面PathnameExpansion中提到的扩展模式匹配特性。
histappend
如果设置的话，在shell退出时，历史列表将追加到以HISTFILE的值为名的文件之后，而不是覆盖文件。
histreedit
如果设置的话，并且正在使用readline，用户可以重新修改失败的历史替换。
histverify
如果设置的话，并且正在使用readline，历史替换的结果不会立即传给shell解释器。结果行被加载到readline编辑缓冲区，允许进行进一步的修改。
hostcomplete
如果设置的话，并且正在使用readline，bash将试着对正在进行补全的包含的词进行主机名补全(参见上面的READLINE中的Completing段落)。这是默认允许的。
huponexit
如果设置的话，在交互的登录shell退出时bash将向所有作业发出SIGHUP信号。
interactive_comments
如果设置的话，将允许在交互shell中遇到以#开头的词时忽略这个词和一行中所有剩余的字符(参见上面的COMMENTS注释)。这个选项是默认允许的。
lithist
如果设置的话，并且允许了cmdhist选项，多行的命令在保存到历史中时将包含新行符，而不是在可能的地方使用分号。
login_shell
如果shell作为登录shell启动，将设置这个选项(参见上面的启动(INVOCATION))。这个值不可修改。
mailwarn
如果设置的话，并且bash正在检测上次检测以来被存取过的邮件，将显示‘‘Themailinmailfilehasbeenread’’(mailfile中的邮件已被读取)。
no_empty_cmd_completion
如果设置的话，并且正在使用readline，试图在空行上执行补全时，bash不会搜索PATH来查找可能的补全。
nocaseglob
如果设置的话，bash进行路径扩展时使用大小写不敏感方式匹配文件名(参见上面的PathnameExpansion路径扩展)。
nullglob
如果设置的话，bash将允许不匹配任何文件的模式扩展为空字符串而不是它们自身(参见上面的PathnameExpansion路径扩展)。
progcomp
如果设置的话，将启用可编程补全功能(参见上面的ProgrammableCompletion)。这个选项是默认启用的。
promptvars
如果设置的话，提示字符串要经过上面PROMPTING中描述的扩展，然后还要经过变量和参数扩展。这个选项是默认启用的。
restricted_shell
shell设置这个选项，如果它是以受限模式启用的(参见下面的受限的shell(RESTRICTEDSHELL)章节)。这个值不能修改。在执行启动文件时，它不会被重置，使得启动文件可以得知shell是否是受限的。
shift_verbose
如果设置的话，内建命令shift在偏移量超过位置参数的个数时打印一条错误消息。
sourcepath
如果设置的话，内建命令source(.)使用PATH中的值来查找包含作为参数给出的文件。这个选项默认是启用的。
xpg_echo
如果设置的话，内建命令echo默认扩展反斜杠转义序列。
suspend[−f]
挂起shell的执行，直到收到一个SIGCONT信号。选项−f表示如果这是一个登录shell，那么不要提示，直接挂起。返回值是0，除非shell是登录shell并且没有指定−f，或者没有启用作业控制。
testexpr
[expr]
返回状态值0或1，根据条件表达式expr的求值而定。每个操作符和操作数都必须是一个单独的参数。表达式使用上面条件表达式(CONDITIONALEXPRESSIONS)中的操作构造。
表达式可以用下列操作符结合，以优先级的降序列出。
!expr
值为真，如果expr为假。
(expr)
返回expr的值。括号可以用来超越操作符的一般优先级。
expr1−aexpr2
值为真，如果expr1和expr2都为真。
expr1−oexpr2
值为真，如果expr1或expr2为真。
test和[使用基于参数个数的一系列规则，对条件表达式进行求值。
0arguments
表达式为假。
1argument
表达式为真，当且仅当参数非空。
2arguments
如果第一个参数是!，表达式为真，当且仅当第二个参数为空。如果第一个参数是上面条件表达式(CONDITIONALEXPRESSIONS)中列出的单目条件运算符之一，表达式为真，当且仅当单目测试为真。如果第一个参数不是合法的单目条件运算符，表达式为假。
3arguments
如果第二个参数是上面条件表达式(CONDITIONALEXPRESSIONS)中列出的二进制条件操作符之一，表达式的结果是使用第一和第三个参数作为操作数的二进制测试的结果。如果第一个参数是!，表达式值是使用第二和第三个参数进行双参数测试的结果取反。如果第一个参数是(，第三个参数是)，结果是对第二个参数进行单参数测试的结果。否则，表达式为假。这种情况下−a和−o操作符被认为二进制操作符。
4arguments
如果第一个参数是!，结果是由剩余参数组成的三参数表达式结果取反。否则，表达式被根据上面列出的优先级规则解释并执行。
5或更多arguments
表达式被根据上面列出的优先级规则解释并执行。
times
对shell以及shell运行的进程，打印累计的用户和系统时间。返回状态是0。
trap[−lp][arg][sigspec...]
当shell收到信号sigspec时，命令arg将被读取并执行。如果没有给出arg或者给出的是−,所有指定的信号被设置为它们的初始值(进入shell时它们的值)。如果arg是空字符串，sigspec指定的信号被shell和它启动的命令忽略。如果arg不存在，并且给出了−p那么与每个sigspec相关联的陷阱命令将被显示出来。如果没有给出任何参数，或只给出了−p，trap将打印出与每个信号编号相关的命令列表。每个sigspec可以是<signal.h>定义的信号名，或是一个信号编号。如果sigspec是EXIT(0)，命令arg将在shell退出时执行。如果sigspec是DEBUG,命令arg将在每个简单命令(simplecommand，参见上面的SHELLGRAMMAR)之后执行。如果sigspec是ERR,命令arg将在任何命令以非零值退出时执行。如果失败的命令是until或while循环的一部分，if语句的一部分，&&或⎪⎪序列的一部分，或者命令的返回值是通过!转化而来，ERR陷阱将不会执行。选项−l使得shell打印信号名和对应编号的列表。shell忽略的信号不能被捕捉或重置。在子进程中，被捕捉的信号在进程创建时被重置为初始值。返回值为假，如果sigspec非法；否则trap返回真。
type[−aftpP]name[name...]
没有选项时，指示每个name将如何被解释，如果用作一个命令名。如果使用了−t选项，type打印一个字符串，内容是如下之一：alias,keyword,function,builtin,或file，如果name分别是一个别名，shell保留字，函数，内建命令或磁盘文件。如果没有找到name，那么不会打印任何东西，返回退出状态假。如果使用了−p选项，type返回如果name作为命令名，将被执行的磁盘文件名；或者返回空，如果‘‘type-tname’’不会返回file.选项−P选项强制对每个name搜索PATH，即使‘‘type-tname’’不会返回file.如果命令在散列中，−p和−P将打印散列的值，而不是PATH中首先出现的那一个文件。如果使用了−a选项，type打印所有包含可执行的名称name的场合。结果包括别名和函数，当且仅当没有同时使用−p选项。使用−a时不会查找散列中的命令表。选项−f阻止shell进行查找，就像在内建命令command中一样。type返回真，如果找到了任何参数。什么都没找到则返回假。
ulimit[−SHacdflmnpstuv[limit]]
在支持它的系统上，对shell和它启动的进程，提供对可用资源的控制。选项−H和−S指定为所给资源设定的硬性和柔性限额。硬性限额在设置后不能增加；柔性限额可以增加，直到与硬性限额相等。如果没有给出−H或−S选项，将同时设置硬性和柔性限额。limit的值可以是一个数字，单位是指定资源的单元值，或者是特殊值hard,soft,或unlimited之一，意思分别是当前硬性限额，当前柔性限额和没有限额。如果忽略了limit，将打印出当前对资源的柔性限额值，除非给出了−H选项。当指定多于一个资源时，限额名称和单位将在值之前打印出来。其他选项按照如下意义解释：
−a
报告所有当前限额
−c
core文件的最大值
−d
进程数据段的最大值
−f
shell创建的文件的最大值
−l
内存中可以锁定的最大值
−m
常驻内存的最大值
−n
打开的文件描述符最大个数(大多数系统不允许设置这个值)
−p
管道大小，以512字节的块为单位(这个值可能不能设置)
−s
栈的最大值
−t
cpu时间总数的最大值，以秒计
−u
用户可以运行的最大进程数
−v
shell可用的虚拟内存总量的最大值
如果给出了limit，它将是指定资源的新限额(选项−a只显示它们)。如果没有给出选项，则假设有−f。值的递增间隔是1024字节，除了−t单位是秒，−p单位是512字节的块个数，−n和−u是不可调节的值。返回0，除非给出了非法的选项或参数，或者在设置新的限额时发生了错误。
umask[−p][−S][mode]
用户创建文件的掩码被设置为mode.如果mode以数字开始，它被解释为一个八进制数；否则被解释为类似于chmod(1)接受的符号形式的模式掩码。如果忽略了mode，将打印当前掩码值。选项−S使得掩码以符号形式打印；默认输出是八进制数。如果给出了−p选项，并且忽略了mode，输出将是一种可以重用为输入的形式。返回值是0，如果成功改变了模式，或者没有给出mode。其他情况返回假。
unalias[−a][name...]
从已定义的别名列表中删除name。如果给出了−a将删除所有别名定义。返回值是真，除非给出的name不是已定义的别名。
unset[−fv][name...]
将每个name对应的变量或函数删除。如果没有给出选项，或者给出了−v选项，name仅包括shell变量。只读的变量不能被取消定义。如果给出了−f选项，name仅包括shell函数，函数的定义将被删除。每个被取消定义的变量或函数都被从后续命令的环境中删除。如果RANDOM,SECONDS,LINENO,HISTCMD,FUNCNAME,GROUPS,或者DIRSTACK中的任何一个被取消定义，它们将丧失特殊的属性，即使它们后来被重新定义。退出状态是真，除非name不存在或是只读的。
wait[n]
等待指定的进程，返回它的终止状态。n可以是进程ID或一个作业号；如果给出的是作业号，将等待作业的管道中所有进程。如果没有给出n，将等待所有当前处于激活状态的子进程，返回状态是0。如果n指定了不存在的进程或作业，返回状态是127。否则，返回状态是所等待的最后一个进程或作业的退出状态。
受限的shell(RESTRICTEDSHELL)

如果bash以rbash名称启动，或者启动时使用了−r选项，那么它成为受限的shell。受限的shell一般用来建立一个比标准的shell受到更多控制的环境。它的行为与bash一致，除了下列行为是不允许的(disallowed)或不会运行的(notperformed)。
•
使用cd来改变路径；
•
设置或取消SHELL,PATH,ENV,或BASH_ENV变量的值；
•
指定的命令名中包含/；
•
指定包含/的文件名作为传递给内建命令.的参数；
•
指定包含斜杠(slash)的文件名作为−p选项的参数，传递给hash内建命令；
•
启动时从shell环境中导入(import)函数定义；
•
启动时解释shell环境中SHELLOPTS的值；
•
使用>,>|,<>,>&,&>,和>>等重定向操作符重定向输出；
•
使用exec内建命令来以另一个命令替换shell；
•
使用enable内建命令的−f和−d选项来增加和删除内建命令；
•
使用enable内建命令来允许和禁止shell内建命令；
•
指定command内建命令的−p选项；
•
使用set+r或set+orestricted来关闭受限模式。
这些限制在所有启动文件读取之后才会生效。
当一个shell脚本作为一个命令执行时(参见上面的命令执行(COMMANDEXECUTION)章节)，rbash关闭为执行脚本而孵化(spawn)的shell的所有限制。
参见("SEEALSO")

BashReferenceManual,BrianFoxandChetRamey
TheGnuReadlineLibrary,BrianFoxandChetRamey
TheGnuHistoryLibrary,BrianFoxandChetRamey
PortableOperatingSystemInterface(POSIX)Part2:Shelland
Utilities,IEEE
sh(1),ksh(1),csh(1)
emacs(1),vi(1)
readline(3)
文件(FILES)

/bin/bash
bash可执行文件
/etc/profile
系统范围的初始化文件，登录shell会执行它
~/.bash_profile
个人初始化文件，登录shell会执行它
~/.bashrc
个人的每个交互式shell启动时执行的文件
~/.bash_logout
个人的登录shell清理文件，当一个登录shell退出时会执行它
~/.inputrc
个人的readline初始化文件
作者(AUTHORS)

BUGS

它太大了，并且有点慢。
bash和传统版本的sh之间有一些细微的差别，大部分是因为POSIX规约的要求。
别名机制在一些应用中会混淆。
Shell内建命令和函数不可终止/重新开始。
组合的命令和使用‘a;b;c’形式的命令序列在进程试图暂停时不能很好处理。当一个进程中止，shell会立即执行序列中的下一条命令。也可以将命令的序列放在圆括号中，来强制启动子shell，这样就可以将它们作为一个单元中止了。
在$(...)命令替换中的注释不会被解释，直到执行替换的时候。这将延迟报错，直到命令开始执行之后的一段时间。
数组变量还不能导出(export)。
