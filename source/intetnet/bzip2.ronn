bzip2(1) -- 块排序文件压缩软件
================================

##总览

bzip2,bunzip2 -- 一种块排序文件压缩软件

bzip2 [ −cdfkqstvzVL123456789 ] [ filenames ... ]
bunzip2 [ −fkvsVL ] [ filenames ... ]

bzcat -- 将文件解压缩至标准输出

bzcat [ −s ] [ filenames ... ]

bzip2recover -- 恢复损坏的bzip2文件

bzip2recover filename

##描述

bzip2采用Burrows-Wheeler块排序文本压缩算法和Huffman编码方式压缩文件。压缩率一般比基于LZ77/LZ78的压缩软件好得多，其性能接近PPM族统计类压缩软件。

命令行参数有意设计为非常接近GNU gzip的形式，但也不完全相同。

bzip2从命令行读入文件名和参数。每个文件被名为"原始文件名.bz2"的压缩文件替换。每个压缩文件具有与原文件相同的修改时间、权限，如果可能的话，还具有相同的属主，因此在解压缩时这些特性将正确地恢复。在某些文件系统中，没有权限、属主或时间的概念，或者对文件名的长度有严格限制，例如MSDOS，在这种情况下，bzip2没有保持原文件名、属主、权限以及时间的机制，从这个意义上说，bzip2对文件名的处理是幼稚的。

bzip2和bunzip2在缺省情况下不覆盖已有的文件。如果想覆盖已有的文件，要指定-f选项。

如果未指定文件名，bzip2将压缩来自标准输入的数据并写往标准输出。在这种情况下，bzip2会拒绝将压缩结果写往终端，因为这完全无法理解并且是没有意义的。

bunzip2(以及bzip2-d)对所有指定的文件进行解压缩处理。不是由bzip2产生的文件将被忽略，同时发出一个警告信息。bzip2按下列方式由压缩文件名确定解压后的文件名：

filename.bz2解压成filename
filename.bz解压成filename
filename.tbz2解压成filename.tar
filename.tbz解压成filename.tar
anyothername解压成anyothername.out

如果文件名的后缀不是下列之一：.bz2,.bz,.tbz2或.tbz,.bzip2将抱怨无法确定原始文件名，并采用原文件名加.out作为解压缩文件名。

在压缩时，如果不提供文件名，bzip2将从标准输入读取数据，压缩结果写往标准输出。

bunzip2能够正确地解压由两个或更多个压缩文件连在一起的文件。解压的结果为相应的连在一起的未压缩文件。
bzip2也支持对连在一起的压缩文件的完整性检查(-t选项)。

同样可采用-c选项将文件压缩或解压缩至标准输出。多个文件可通过这种方式压缩或解压缩。输出结果被依次送往标准输出。采用这种方式对多个文件的压缩将生成包含多个压缩文件的数据流。这样的数据流只能被0.9.0版或其后续版本的bzip2正确解压。较早版本的bzip2会在解压完第一个文件之后停止。

bzcat(或bzip2-dc)将所有指定文件解压缩至标准输出。

bzip2可从环境变量BZIP2和BZIP中依次读取参数，并在命令行参数之前对其进行处理。这是提供缺省选项的方便途径。

即使压缩后的文件略大于原文件，压缩也总是照样进行。小于大约100字节的文件压缩后倾向于变大，因为会有一个50字节的数据头。对于随机数据（包括大多数压缩软件的输出），大约每字节压成8.05位，放大率约为0.5%。

bzip2采用32位CRC校验码作自我检查，以确认解压后的文件与原始文件相同。这可用于检测压缩文件是否损坏，并防止bzip2中未知的缺陷（运气好的话这种可能性非常小）。数据损坏而未检测到的几率非常之小，对于每个被处理的文件大约是四十亿分之一。检查是在解压缩时进行的，因此它只能说明某个地方出问题了。它能帮助恢复原始未压缩的数据。可以用bzip2recover来尝试从损坏的文件中恢复数据。

返回值：正常退出返回0，出现环境问题返回1（文件未找到，非法的选项，I/O错误等），返回2表明压缩文件损坏，出现导致bzip2紧急退出的内部一致性错误（例如缺陷）时返回3。
选项

-c--stdout

将数据压缩或解压缩至标准输出。

-d--decompress

强制解压缩。bzip2,bunzip2以及bzcat实际上是同一个程序，进行何种操作将根据程序名确定。指定该选项后将不考虑这一机制，强制bzip2进行解压缩。

-z--compress

-d选项的补充：强制进行压缩操作，而不管执行的是哪个程序。

-t--test

检查指定文件的完整性，但并不对其解压缩。实际上将对数据进行实验性的解压缩操作，而不输出结果。

-f--force

强制覆盖输出文件。通常bzip2不会覆盖已经存在的文件。该选项还强制bzip2打破文件的硬连接，缺省情况下bzip2不会这么做。

-k--keep

在压缩或解压缩时保留输入文件（不删除这些文件）。

-s--small

在压缩、解压缩及检查时减少内存用量。采用一种修正的算法进行压缩和测试，每个数据块仅需要2.5个字节。这意味着任何文件都可以在2300k的内存中进行解压缩，尽管速度只有通常情况下的一半。

在压缩时，-s将选定200k的块长度，内存用量也限制在200k左右，代价是压缩率会降低。总之，如果机器的内存较少（8兆字节或更少），可对所有操作都采用-s选项。参见下面的内存管理。

-q--quiet

压制不重要的警告信息。属于I/O错误及其它严重事件的信息将不会被压制。

-v--verbose

详尽模式--显示每个被处理文件的压缩率。命令行中更多的-v选项将增加详细的程度，使bzip2显示出许多主要用于诊断目的信息。

-L--license-V--version

显示软件版本，许可证条款及条件。

-1to-9

在压缩时将块长度设为100k、200k..900k。对解压缩没有影响。参见下面的内存管理。
	

--
		

将所有后面的命令行变量看作文件名，即使这些变量以减号"-"打头。可用这一选项处理以减号"-"打头的文件名，例如：bzip2---myfilename.

--repetitive-fast--repetitive-best

这些选项在0.9.5及其以上版本中是多余的。在较早的版本中，这两个选项对排序算法的行为提供了一些粗糙的控制，有些情况下很有用。0.9.5及其以上版本采用了改进的算法而与这些选项无关。
内存管理

bzip2按照数据块压缩大文件。数据块长度同时影响数据的压缩率和压缩及解压缩时需要的内存用量。选项-1至-9将数据块长度分别指定为100,000字节至900,000（缺省）字节。在解压缩时，压缩时使用的块长度从压缩文件的头中读取，同时bunzip2分配出刚好够用的内存对文件进行解压缩。由于数据块长度保存在压缩文件中，所以在解压缩时不需要-1至-9这些选项，因而将被忽略。

可以按下面的公式估计压缩和解压缩时的内存用量，单位为字节：

压缩:400k+(8x数据块长度)

解压缩:100k+(4x数据块长度),或
100k+(2.5x数据块长度)

大数据块长度产生迅速缩小的临界返回(giverapidlydiminishingmarginalreturns)。在小机器上使用bzip2时，一个值得记住的事实是，大多数压缩来自数据块长度的前200或300k。另外重要的一点是，解压缩时内存的需要量是在压缩时用块长度选项设定的。

对于缺省用900k的数据块长度压缩的文件，bunzip2大约需要3700k字节的内存进行解压缩。为支持一台4MB机器上任何文件的解压缩，bunzip2有一个选项大约只需一半容量的内存，约2300k字节。解压缩速度同样也降低一半。因此应该只在需要时采用该选项。相应的选项标志为-s。

一般来说，应尽量采用内存允许的最大数据块长度，因为这能达到最好的压缩率，压缩和解压缩速度实质上不受块长度的影响。

另一个值得注意的问题是关于小于一个数据块长度的文件的，也就是说，所遇到的大多数文件使用一个大数据块。由于文件长度小于一个数据块长度，实际使用到的内存与文件长度成正比。例如，采用-9选项压缩一个20,000字节的文件时，将分配7600k的内存，但其中只用到了400k+20000*8=560k字节。同样地，在解压缩时将分配3700k内存，但只用到100k+20000*4=180k字节。

下表总结了不同数据块长度下的内存用量。同时列出的还有Calgary文本压缩语料库中的14个文件的压缩长度，这14个文件压缩前总长度为3,141,622字节。这些数据显示了压缩率是如何随数据块长度变化的。由于这一语料库主要由小文件组成，所以这些数字并没有充分体现出大文件情况下，采用大数据块所能达到的较高压缩率的优势。

压缩时解压缩解压缩-s语料库文件
Flag内存用量内存用量选项内存用量压缩长度

-11200k500k350k914704
-22000k900k600k877703
-32800k1300k850k860338
-43600k1700k1100k846899
-54400k2100k1350k845160
-65200k2500k1600k838626
-76100k2900k1850k834096
-86800k3300k2100k828642
-97600k3700k2350k828642
从损坏的文件中恢复数据

bzip2按数据块对数据进行压缩，数据块长度通常为900k字节。每个数据块被独立地处理。如果由于介质或传输错误导致多数据块的.bz2文件损坏，有可能将文件中未损坏的数据块中的数据恢复。

压缩后的数据块以一个48位的结构分界，因而有可能在合理的范围内找到块边界。每个数据块也带着自己的32位CRC校验码，因此可以区分损坏与未损坏的数据块。

bzip2recover是一个简单的程序，它的功能是在.bz2文件中寻找数据块，并将每个数据块写到自己的.bz2文件中。然后可以用bzip2-t测试结果的完整性，将未损坏的部分解压缩。

bzip2recover只有一个命令行变量，即损坏文件的名字。输出结果是一系列象"rec0001file.bz2"、"rec0002file.bz2"这样的文件，每个文件含有从损坏文件中找出的数据块。输出文件名设计为在接下来的处理中可方便地使用通配符，例如，"bzip2-dcrec*file.bz2>recovered_data"，可按正确的次序列出文件。

bzip2recover在处理大文件时最有用，因为大文件含有很多数据块。显然用它处理单个数据块的损坏文件不会有任何结果，因为一个损坏的数据块是无法恢复的。如果想尽量减少潜在的由于介质及传输错误导致的数据损坏，可以考虑采用较小的数据块长度进行压缩。
有关性能的注解

在压缩的排序阶段，相似的字符串将被聚集在一起。因此，对于包含很长重复符号的文件，例如象"aabaabaabaab......"这样的字符串（重复几百次），压缩速度会比通常情况慢得多。0.9.5及其以上版本在处理这样的重复时，速度比以前版本提高了很多。最坏情况与平均情况下的压缩时间之比约为10:1。对于以前的版本，这一数字大约是100:1以上。你如果愿意，可采用-vvvv选项来非常详细地监视这一过程。

解压缩速度并不受这些现象的影响。

bzip2通常分配出几兆字节的内存用于处理数据，对这些内存的访问是以相当随机的方式进行的。这意味着，压缩及解压缩的性能在很大程度上取决于机器上处理高速缓存未命中的速度。因此，已经观察到对程序作很小的减少失败率的改动会导致不成比例的很大的性能上的提升。我设想bzip2在有大量高速缓存机器上的性能最佳。
警告

I/O错误信息并不是很有用。bzip2会尽量探测I/O错误信息并干净地退出，但问题的细节有时看上去很容易引起误解。

本手册页适用于0.9.5版的bzip2。由这一版本的bzip2产生的压缩数据与以前的公开版本0.1pl2、0.9.0完全兼容，但有一个例外：0.9.0及其以上版本能正确解压缩多个连在一起的压缩文件，0.1pl2则不能，它将在解压缩完数据流中的第一个文件之后停止。

bzip2recover采用32位的整型数表示压缩文件中位的位置，因此它无法处理大于512兆字节的文件。但这一问题很容易解决。
作者

JulianSeward,jseward@acm.org.

http://www.muraroa.demon.co.uk

bzip2包含的想法及概念至少归功于下列人员：MichaelBurrows和DavidWheeler（块排序变换），DavidWheeler（Huffman编码器），PeterFenwick（原始bzip的结构编程模型及许多改进），AlistairMoffat、IanWitten（原始bzip中的算法编码）。我非常感激他们的帮助、支持以及建议。参见源发布的手册中有关文档来源中的线索。ChristianvonRoques曾鼓励我寻找更快的排序算法，以提高压缩速度。belaLubkin曾鼓励我改进最坏情况下的压缩性能。很多人给我发来修补程序，帮助解决移植问题，租借机器，提出建议等。
